In this chapter we validate and evaluate the expressiveness of the JS-QL query language by expressing some existing security policies, described in other related work, in our own query language. We will then compare these policies in terms of expressiveness and flexibility. %TODO: Vergelijken op welke manier
The concept and approach for creating a new, domain-specific language for security policies is explained in chapter \ref{ch:QueryLanguage}. Chapter \ref{ch:QueryEngine} discusses the underlying query engine and how it works together with the query language to process the application-specific policies. In chapter \ref{ch:Implementation} we explain how our approach was instantiated.

We start this chapter by expressing 9 security policies distilled from 3 papers in sections \ref{sec:ValidationPidginQL}, \ref{sec:ValidationGK} and \ref{sec:ValidationConscript} respectively. Every JS-QL policy will be evaluated by comparing how well it matches the policy expressed in the original paper. Finally, in section \ref{sec:ValidationEvaluation}, we evaluate the query framework by specifying its advantages, disadvantages and limitations. We will also briefly compare the query languages presented in this chapter in terms of expressiveness, verbosity and conciseness (\textit{LOC}).
%TODO: wat gaan we nog comparen?
%TODO: JAVASCRIPT SOURCE CODE ADDEN
\section{the GateKeeper language}
\label{sec:ValidationGK}

In this chapter we attempt to express 3 policies originally presented in \cite{GateKeeper}.

\subsection{Writes to prototype objects}

Many websites use bookmarklets to store user information to automate the login process, for example \cite{PrototypePoisoning}. This is a common strategy used to reduce the amount of information the user has enter every time he visits the website. An attacker website however, can alter the JavaScript environment in such a way that he can steal all of this information from the user. Imagine a simple login function, which checks the current location of the webpage to verify that it is on the correct webpage. The current location can be compromised by overwriting the \texttt{toString} function of the \texttt{String} object, as depicted in \ref{lst:PrototypePoisoning}. This function can be configured to always return a "good" location. In this way, the login function will be called in the environment of a malicious website, possibly leaking sensitive information.

\begin{lstlisting}[label={lst:PrototypePoisoning},language=JavaScript,caption=Prototype poisoning example,mathescape=true]  % float=t?

String.prototype.toString = function(){
    //Always return "spoofed" url
    return "www.goodwebsite.com";
}

var login = function(){
  if(document.location.toString() === "www.goodwebsite.com"){
    //leak information on untrusted website
  }
}
\end{lstlisting}

%gatekeeper doet het zo
Gatekeeper expresses policies by defining a set of rules in datalog. In order to detect writes to prototypes of frozen objects, they define the \texttt{FrozenViolation(v)} predicade, as shown in listing \ref{lst:Policy1GK}. This predicate first looks for all stores of field \texttt{v}. This field points to location \texttt{h2}, which represents the points-to address for variables. Only writes to builtin objects are infringements of the policy, which implies that \texttt{h2} has to point to a field of of one of these objects. This is expressed as follows: In \texttt{BuiltInObjects(h)}, \texttt{h} points to the heap location of a builtin object. The \texttt{Reaches(h1,h2)} predicate makes sure that the field that was stored reaches the builtin object directly or indirectly, by recursively checking if one of the properties of the builtin object has a field pointing to the stored field.

\begin{lstlisting}[label={lst:Policy1GK},language=Prolog,caption=Policy 1 in GateKeeper,mathescape=true]  % float=t?

Reaches(h1,h2) :- HeapPtsTo(h1,_,h2).
Reaches(h1,h2) :- HeapPtsTo(h1,_,h3),
                  Reaches(h3,h2).

FrozenViolation(v) :- Store(v,_,_),
                      PtsTo(v,h2),
                      BuiltInObject(h1),
                      Reaches(h1,h2).

% Specify all built in objects
BuiltInObject(h) :- GlobalSym("String", h).
BuiltInObject(h) :- GlobalSym("Array", h).
% ...

GlobalSym(m,h) :- PtsTo("global", g),
                  HeapPtsTo(g,m,h).

\end{lstlisting}

%ik doe het zo (geef voorbeeld voor ééntje, zeggen dat we een compound query hebben gemaakt voor om te bundelen)
Writing this policy in JS-QL is easy. To ease the work for the programmer, we augmented the Jipda-nodes corresponding with \texttt{MemberExpression}s two extra fields: \texttt{mainObjectName} and \texttt{properties}, representing the root object and the property-chain array that was accessed respectively. An example: for \texttt{o.x.y.z}, \texttt{o} would be the \texttt{mainObjectName}, and \texttt{[x,y,z]} would be the array \texttt{properties} which represents the properties that were chained. Listing \ref{lst:Policy1JSQL} depicts the JS-QL query to efficiently express this policy. Note that the filter on lines 10-12 can be omitted. This filter simply indicates that we only want to detect writes to the \texttt{prototype} property of the \texttt{String} object. When this is omitted, we will detect all writes to this object.

\begin{lstlisting}[label={lst:Policy1JSQL},language=JavaScript,caption=Policy 1 in JS-QL,mathescape=true]  % float=t?

G.skipZeroOrMore()
.state({
  node:{
    expression:{
      left:{
        properties: '?props',
        mainObjectName: 'String'
      }
    }
  },
  filters:[
    cond('contains', '?props', 'prototype')
  ]
})

\end{lstlisting}

This example JS-QL policy only detects writes to the \texttt{String} object. We wrote a compound policy \texttt{writeToBuiltinObjectPrototype} to detect writes to all builtin objects' prototype property. The code for this policy can be found in listing \ref{lst:WriteToBuiltinObjectPrototype} in the appendix. This policy is just the disjunction of states similar to the state in listing \ref{lst:Policy1JSQL}, with the only difference in the \texttt{mainObjectName} property, which corresponds to a different builtin object name.
%TODO: bespreken

\subsection{Global namespace pollution}

Working in a JavaScript environment often involves the inclusion of multiple (third-party) scripts. These scripts offer instant access to functionality which would be tiresome to implement for every project yourself. Some of these scripts are written by other parties, so one can't be sure that they follow the same coding guidelines as he does. Inexperienced programmers might not be aware of the JavaScript namespacing patterns \cite{JSNamespacing}. This leaves an open window for a phenomenon called "global namespace pollution". Defining variables in the global scope in JavaScript can lead to unanticipated behaviour of the program when another script defines a global variable with the same name.

Preventing stores to the global object (i.e. in the global scope) can be enforced through a simple two-lined GateKeeper policy. GateKeeper handles the global object explicitly by defining a variable \texttt{global}. Global variables can then be simulated as fields of this object. Note that JIPDA does this in a similar way. A policy to detect global stores can then be defined as in \ref{lst:Policy3GK}: The global object variable is located on address \texttt{g}. Every field store \texttt{h} that points to a field of \texttt{g} will then be detected by the \texttt{GLobalStore}.

\begin{lstlisting}[label={lst:Policy3GK},language=Prolog,caption=Policy 3 in GateKeeper,mathescape=true]  % float=t?

GlobalStore(h) :- PtsTo("global",g),
                  HeapPtsTo(g,_,h).
\end{lstlisting}


\subsection{Script inclusions}

A well known exploit in JavaScript environments is \textit{heap spraying}. This is an attacking technique that can eventually even compromise a user's system. In short, it arranges the layout of the heap by allocating a vast amount of carefully-chosen strings, installing a certain sequence of bytes at a predetermined location in the memory of a target. When this is achieved, the exploit is triggered. This trigger depends on the user's operating system and browser. Such an agressive attack can be instantiated on the victim's computer by simply including a malicious script. This could be a reason to write a policy which detects all script inclusions. Regular script inclusions through \texttt{<script></script>} tags can be detected by hand. Javascript however also allows programmers to write arbitrary HTML code by using the \texttt{document.write} and \texttt{document.writeln} functions. Listing \ref{lst:ScriptInclusion} gives an example of malicious script inclusions.

\begin{lstlisting}[label={lst:Policy2GK},language=JavaScript,caption=Script inclusion example,mathescape=true]  % float=t?

var evilScript;
var scripts = ["<script>bad1</script>","<script>bad2</script>"];

for(var i = 0; i < scripts.length; i++){
  evilScript = scripts[i];
  document.write(evilScript); //violation
}

var o = {};
o.f = document.writeln;
o.f("<script>bad3</script>"); //Violation
\end{lstlisting}

This policy can be written with only a few lines of datalog in GateKeeper. What needs to be detected are the calls to \texttt{document.write/document.writeln}, even when they are aliased. This is important to note because scripts used for attacks are often obfuscated. The policy in listing \ref{lst:Policy2GK} does just that. \texttt{DocumentWrite(i)} first looks for the address \texttt{d} on the heap which points to the global \texttt{document} object. Next, the location of the property \texttt{write/writeln} of that object is reified in variable \texttt{m}. This is also an address on the heap. The last step is to find all call sites \texttt{i} that point to that same address on the heap. 

\begin{lstlisting}[label={lst:Policy2GK},language=Prolog,caption=Policy 2 in GateKeeper,mathescape=true]  % float=t?

DocumentWrite(i) :- GlobalSym("document",d),
                    HeapPtsTo(d,"write",m),
                    Calls(i,m).

DocumentWrite(i) :- GlobalSym("document",d),
                    HeapPtsTo(d,"writeln",m),
                    Calls(i,m).
\end{lstlisting}

JS-QL also proves to be suitable to express such a policy in listing \ref{lst:Policy2JSQL}. The approach we take first skips zero or more states in the JIPDA graph. We specify that we then want to find a function call with the name of the function bound to metavariable \texttt{?name}. In order to know to which address the called function points in the store, we look it up and bind the address to \texttt{?addr} in the lookup-clause of the \texttt{fCall} predicate. Finally we also match the address of \texttt{document.write/document.writeln} to the same \texttt{?addr} metavariable, filtering out all function calls that do not point to this address.

The analysis that we use is context-sensitive and Javascript is lexically scoped. This implies that we need to explicitly specify that we are looking for the address of the \textit{global} \texttt{document.write/document.writeln} object. If we didn't do this and the user has defined an object with the name "document" and a property "write" or "writeln" inside the scope of the current node in the graph, we would get the address of that object instead of the global object. That is why JS-QL provides a \texttt{\_global} keyword which indicates that we need to search for the address in the global namespace. 

\begin{lstlisting}[label={lst:Policy2JSQL},language=JavaScript,caption=Policy 2 in JS-QL,mathescape=true]  % float=t?

G.skipZeroOrMore()
.lBrace()
.fCall({
  name: '?name',
  lookup:{
    '?name'   : '?addr',
    '$\_$global.document.write': '?addr',
    }
})
.or()
.fCall({
  name: '?name',
  lookup:{
    '?name'   : '?addr',
    '$\_$global.document.writeln': '?addr',
    }
})
.rBrace()
\end{lstlisting}

%GK is flow insensitive, mijn vb gaat meer vinden

\subsection{Conclusion}

\section{The PidginQL language}
\label{sec:ValidationPidginQL}

In this chapter we attempt to express 3 policies originally presented in \cite{PidginQLTechReport}.
%TODO uitleggen hoe zij hun graph voorstellen (verwijzen naar RW).

\subsection{Only CMS administrators can send a message to all CMS users}
%Context uitleg
Imagine a situation where not only administrators can send broadcast messages. A regular user with bad intentions could easily take advantage of this situation to cause harm to the system. A CMS application for instance with a decent size of users could be exploited by sending a message to all users, asking them to reply with their password. When the attacker provides a reason to the victims convincing them to send their password, he could possibly compromise the contents of the victim's account. An example of such a reason could be that the 'administrator' needs to have the password of a user account in order to update the software of that user to the latest version. This behaviour is undesirable, thus we need a policy which prevents regular users from sending such messages.

The policy listed in \cite{PidginQLTechReport} that addresses this issue can be found in listing \ref{lst:Policy4PidginQL}. First, all nodes that are entries of the \texttt{addNotice} method are searched for and stored in a variable. \texttt{addNotice} is the method that sends messages to all users, and has the same behaviour as the broadcast method in the explanation above. Next, all points in the PDG are found that match a return node of the \texttt{isCMSAdmin} method with a return value which is truthy. In order to know if there exists some path in the graph where \texttt{addNotice} is called when the return value of \texttt{isCMSAdmin} is false, all paths between the nodes in \texttt{addNotice} and \texttt{isAdmin} are removed from the graph for all paths where \texttt{isAdmin} is true. Finally, the intersection of the nodes in this 'unsanitized' graph and the nodes in the \texttt{sensitiveOps} argument is taken. When this intersection is not empty, we can assume that there is a violation of the policy in the remainder of the graph. This last part is exactly what the \texttt{accessControlled} method does.

%AccessControlled = let accessControlled(G, checks, sensitiveOps) = G.removeControlDeps(checks) ∩ sensitiveOps is empty
\begin{lstlisting}[label={lst:Policy4PidginQL},language=JavaScript,caption=Policy 4 in PidginQL,mathescape=true]  % float=t?

let accessControlled(G, checks, sensitiveOps) = 
    G.removeControlDeps(checks) $\cap$ sensitiveOps is empty

let addNotice = pgm.entriesOf("addNotice") in
let isAdmin   = pgm.returnsOf("isCMSAdmin") in 
                pgm.accessControlled(isAdmin, addNotice)
\end{lstlisting}

When attempting to write a similar query in JS-QL, we need to define the problem in terms of control flow: "There must be no path between the returns of the \texttt{isCMSAdmin}, when the return value is false, and a call of the \texttt{addNotice} method." We must note that with abstract interpretation, it is not trivial to specify whether a value is truthy or falsy. When looking at a conditional (like an \texttt{if-statement}), we can determine whether the true- of false-branch has been taken by comparing the first node of the branches with the alternate/consequent of the conditional. However, for values with the value of \textit{\{Bool\}}, we cannot decide on which branch is the true-branch and which one is the false-branch. We can solve this in two ways: We can assume that the condition in the conditional is a direct call to \texttt{isCMSAdmin}, which enables us to find the false-branch. From there on we can search for all calls to \texttt{addNotice} to find violations. The JS-QL policy for this case is defined in listing \ref{lst:Policy4JSQL}. We skip all states untill we reach the beginning of a false branch of a conditional. We bind the condition \textit{test} to the metavariable \textit{?cond}, the context \textit{kont} to \textit{?kont} and the stack \textit{lkont} to \textit{?lkont}. We further restrict condition \textit{?cond} to contain the 'callee' property, of which we take the name and match it to the 'isCMSAdmin' literal. Next, we skip some states until we find a call to the \texttt{addNotice} method. Since we only want to detect these calls within the false-branch, we end the policy with an \texttt{endIf} predicate with matching stack and context metavariables.

Another option is to find all calls to the \texttt{addNotice} method that follow a return of \texttt{isCMSAdmin}. Since we only know that the return value of \texttt{isCMSAdmin} returns a value of \textit{\{Bool\}}, we are unable to rule out any of the branching options. This will result in false-positives. Listing \ref{lst:Policy4JSQL} gives an implementation of the policy. We again match the stack and context to metavariables \textit{?lkont} and \textit{?kont}, but this time to indicate the start of a function application. Next we specify that we want to find all return statements within that function application. This is done by indicating that these return statements must follow a node which is not the end of the function application, parametrized with the same metavariables for stack and context. Finally, some states can be skipped before finding a function call to \texttt{addNotice}.

\begin{lstlisting}[label={lst:Policy4JSQL},language=JavaScript,caption=Policy 4 in JS-QL]  % float=t?

//First solution
G.skipZeroOrMore()
.beginIfFalse({test: '?cond', kont: '?kont', lkont:'?lkont', 
               properties:{
                 'isCMSAdmin' : '?cond.callee.name'
               }})
.skipZeroOrMore()
.fCall({name:'addNotice'})
.skipZeroOrMore()
.endIf({kont: '?kont', lkont:'?lkont'})

//Second solution
G.skipZeroOrMore()
.beginApply({name:'isCMSAdmin',kont:'?kont',lkont:'?lkont'})
.not()
    .endApply({ kont:'?kont',lkont:'?lkont'})
    .star()
.returnStatement()
.skipZeroOrMore()
.fCall({name:'addNotice'})

\end{lstlisting}

%Vergelijken
%Ook al vinden we bij eentje false positives, de andere matcht in principe alle calls naar addNotice als er geen isAdmin aangeroepen wordt. (Bij mij is het enkel indien gewenst [surrounden door braces en star toevoegen])
%Bij de andere is de restriction eerder JIPDA-related (statische analyse), want het framework en de taal laten wel toe om te filteren op value bijvoorbeeld
%Zij zeggen enkel of de set leeg is of niet, wij geven resultaten
%Kunnen zij velden checken?

\subsection{A database is opened only after the master password
is checked or when creating a new database}
%TODO

\begin{lstlisting}[label={lst:Policy5PidginQL},language=JavaScript,caption=Policy 5 in PidginQL,mathescape=true]  % float=t?

TODO
\end{lstlisting}

\subsection{Public outputs do not depend on a users's password, unless it has been cryptographically hashed}
%TODO

\begin{lstlisting}[label={lst:Policy6PidginQL},language=JavaScript,caption=Policy 6 in PidginQL,mathescape=true]  % float=t?

let passwords = pgm.returnsOf("getPassword") in 
let outputs   = pgm.formalsOf("writeToStorage") $\cup$
                pgm.formalsOf("print") in
let hashFormals = pgm.formalsOf("computeHash") in
pgm.declassifies(hashFormals, passwords, outputs)
\end{lstlisting}

\subsection{conclusion}

\section{The Conscript language}
\label{sec:ValidationConscript}

\subsection{No string arguments to setInterval, setTimeout}

\begin{lstlisting}[label={lst:Policy7Conscript},language=JavaScript,caption=Policy 7 in ConScript,mathescape=true]  % float=t?

let onlyFnc : K x U x U -> K =
function (setWhen : K, fn : U, time : U) {
    if ((typeof fn) != "function") {
        curse();
        throw "The time API requires functions as inputs.";
    } else {
        return setWhen(fn, time);
    }
};
around(setInterval, onlyFnc); 
around(setTimeout, onlyFnc);
\end{lstlisting}

\subsection{HTTP-cookies only}

\begin{lstlisting}[label={lst:Policy8Conscript},language=JavaScript,caption=Policy 8 in ConScript,mathescape=true]  % float=t?

let httpOnly:K->K=function(_:K){ 
    curse(); 
    throw "HTTP-only cookies"; 
};
around(getField(document, "cookie"), httpOnly); 
around(setField(document, "cookie"), httpOnly);
\end{lstlisting}

\subsection{Prevent resource abuse}

\begin{lstlisting}[label={lst:Policy9Conscript},language=JavaScript,caption=Policy 9 in ConScript,mathescape=true]  % float=t?

let err : K -> K = function () { 
    curse(); 
    throw 'err'; 
}); 
around(prompt, err); 
around(alert, err);
\end{lstlisting}

\section{Evaluation}
\label{sec:ValidationEvaluation}
%Nadeel bvb eerste policy van PidginQL: we kunnen niet naar concrete waarden kijken , bvb user.isAdmin zal {bool zijn}, maar weet niet of dit true of false is

\begin{center}
    \begin{tabular}{ | l || l | l | l |}
    \hline
    Language & Prop1 & Prop2 & Prop3 \\ \hline
    JS-QL &  &  & \\ \hline
    GateKeeper &  &  & \\ \hline
    PidginQL &  &  & \\ \hline
    Conscript &  &  & \\ \hline
    \end{tabular}
\end{center}
