In this chapter we validate and evaluate the expressiveness of the JS-QL query language by expressing 9 security vulnerabilities distilled from 3 papers in sections \ref{sec:ValidationPidginQL}, \ref{sec:ValidationGK} and \ref{sec:ValidationConscript} respectively. Every vulnerability expressed in JS-QL will be evaluated by comparing how well it matches the vulnerability expressed in the original paper. Finally, in section \ref{sec:ValidationEvaluation}, we evaluate the our tool by specifying its advantages and limitations. We will also briefly compare the query languages presented in this chapter in terms of expressiveness, verbosity and conciseness.
%TODO: wat gaan we nog comparen?
%TODO: JAVASCRIPT SOURCE CODE ADDEN
\section{The GateKeeper language}
\label{sec:ValidationGK}

In this section we express 3 vulnerabilities originally presented in GateKeeper. GateKeeper is a mostly static approach for soundly enforcing security and reliability policies for JavaScript programs~\cite{GateKeeper}. Programs are represented as a database of Datalog rules, against which GateKeeper policies (also written in Datalog) are checked.

\subsection{Writes to prototype objects}

Many websites use bookmarklets to store user information to automate the login process, as for example discussed by Adida et al.~\cite{PrototypePoisoning}. This is a common strategy used to reduce the amount of information the user has to enter every time he visits the website. An attacker website however can alter the JavaScript environment in such a way that he can steal all of this information from the user. Imagine a simple login function which checks the current location of the webpage to verify that it is on the correct webpage. The current location can be compromised by overwriting the \texttt{toString} function of the \texttt{String} object, as depicted in listing \ref{lst:PrototypePoisoning}. This function can be configured to always return a ``good'' location. In this way, the login function can be called in the environment of a malicious website, possibly leaking sensitive information.

\begin{lstlisting}[label={lst:PrototypePoisoning},language=JavaScript,caption=Prototype poisoning example,mathescape=true]  % float=t?

String.prototype.toString = function(){
    //Always return "spoofed" url
    return "www.goodwebsite.com";
}

var login = function(){
  if(document.location.toString() === "www.goodwebsite.com"){
    //leak information on untrusted website
  }
}
\end{lstlisting}

%gatekeeper doet het zo
\subsubsection*{GateKeeper policy}
Gatekeeper expresses vulnerabilities by defining a set of rules in datalog. For example, in order to detect writes to prototypes of builtin objects, GateKeeper defines the \texttt{FrozenViolation(v)} predicade, shown in listing \ref{lst:Policy1GK}. This predicate first looks for all stores of field \texttt{v}. This field points to location \texttt{h2}, which represents the points-to address for variables. Only writes to builtin objects are infringements of the policy, which implies that \texttt{h2} has to point to a field of of one of these objects. This is expressed as follows: in \texttt{BuiltInObjects(h)}, \texttt{h} points to the heap location of a builtin object. The \texttt{Reaches(h1,h2)} predicate makes sure that the field that was stored reaches the builtin object directly or indirectly, by recursively checking if one of the properties of the builtin object has a field pointing to the stored field.

\begin{lstlisting}[label={lst:Policy1GK},language=Prolog,caption=Policy 1 in GateKeeper,mathescape=true]  % float=t?

Reaches(h1,h2) :- HeapPtsTo(h1,_,h2).
Reaches(h1,h2) :- HeapPtsTo(h1,_,h3),
                  Reaches(h3,h2).

FrozenViolation(v) :- Store(v,_,_),
                      PtsTo(v,h2),
                      BuiltInObject(h1),
                      Reaches(h1,h2).

% Specify all built-in objects
BuiltInObject(h) :- GlobalSym("String", h).
BuiltInObject(h) :- GlobalSym("Array", h).
% ...

GlobalSym(m,h) :- PtsTo("global", g),
                  HeapPtsTo(g,m,h).

\end{lstlisting}

\subsubsection*{JS-QL policy}
JS-QL also supports expressing similar queries. We augmented the JIPDA-nodes corresponding with \texttt{MemberExpression}s with two extra fields: \texttt{mainObjectName} and \texttt{properties}, representing the root object and the property-chain array that was accessed respectively. An example: for memberexpression \texttt{o.x.y.z}, \texttt{o} is the \texttt{mainObjectName}, and \texttt{[x,y,z]} is the array \texttt{properties} which represents the properties that are chained. Listing \ref{lst:Policy1JSQL} depicts the JS-QL query to efficiently express this vulnerability. Note that the filter on lines 10-12 can be omitted. This filter indicates that we only want to detect writes to the \texttt{prototype} property of the \texttt{String} object. When this is omitted, we will detect all writes to this object.

\begin{lstlisting}[label={lst:Policy1JSQL},language=JavaScript,caption=Policy 1 in JS-QL,mathescape=true]  % float=t?

G.skipZeroOrMore()
.state({
  node:{
    expression:{
      left:{
        properties: '?props',
        mainObjectName: 'String'
      }
    }
  },
  filters:[
    cond('contains', '?props', 'prototype')
  ]
})

\end{lstlisting}

This example JS-QL policy only detects writes to the \texttt{String} object. We wrote a compound policy \texttt{writeToBuiltinObjectPrototype} to detect writes to all builtin objects' prototype property. The code for this policy can be found in listing \ref{lst:WriteToBuiltinObjectPrototype} in the appendix. This policy is just the disjunction of states similar to the state in listing \ref{lst:Policy1JSQL}, with the only difference in the \texttt{mainObjectName} property, which corresponds to a different builtin object name.

\subsubsection*{Discussion}
JS-QL proves to be able to express the prototype poisoning policy, as well as similar policies. The GateKeeper policy was more verbose compared to its JS-QL equivalent, indicating that JS-QL policies can be concise while remaining expressive.


\subsection{Global namespace pollution}


Working in a JavaScript environment often involves the inclusion of multiple (third-party) scripts. These scripts offer access to functionality which would be tiresome to implement for every project yourself. Some of these scripts are written by other parties, so developers cannot be sure that these parties follow the same coding guidelines as they do. Inexperienced programmers might not be aware of the JavaScript namespacing patterns~\cite{JSNamespacing}. This leaves an open window for a phenomenon called ``global namespace pollution''. Defining variables in the global scope in JavaScript can lead to unanticipated behaviour of the program when another script defines a global variable with the same name.

\subsubsection*{GateKeeper policy}
Preventing stores to the global object (i.e. in the global scope) can be enforced with a two-line GateKeeper policy. GateKeeper handles the global object explicitly by defining a variable \texttt{global}. Global variables can then be simulated as fields of this object. A policy to detect global stores can then be defined as in listing \ref{lst:Policy2GK}: The global object variable is located on address \texttt{g}. Every field store \texttt{h} that points to a field of \texttt{g} will then be detected by the \texttt{GlobalStore} policy.

\begin{lstlisting}[label={lst:Policy2GK},language=Prolog,caption=Policy 2 in GateKeeper,mathescape=true]  % float=t?

GlobalStore(h) :- PtsTo("global",g),
                  HeapPtsTo(g,_,h).
\end{lstlisting}


\subsubsection*{JS-QL policy}
We could write a similar policy in JS-QL that would also verify whether the address of the variable points to the global object. However, this is more difficult in our system because of the flog graph generated by JIPDA. When a variable or function gets declared or when a variable is assigned to, the right-hand side first has to be evaluated. This is also reflected in the JIPDA graph. Only when the expression is evaluated, the store and environment are modified to contain the recently evaluated information. The allocation address for newly created variables is not yet available in the states we query on lines 3,5 and 7 in listing \ref{lst:Policy2JSQL}. We remedy this by looking further down the graph, more specifically in the states where this information \textit{is} available. 

The policy is implemented as follows: After skipping to an assignment or a declaration of a function or variable, we bind the name the variable's or function's name to metavariable \texttt{?name}. We then again skip some nodes until we find a state where the address of \texttt{?name} is available and bind it to \texttt{?nameAddress}. Finally, we search for the variable or function with the same name in the global object and also bind it to \texttt{?nameAddr}, which filters the resulting substitutions to only contain information about globally declared objects.

\begin{lstlisting}[label={lst:Policy2JSQL},language=JavaScript,caption=Policy 2 in JS-QL,mathescape=true]  % float=t?

G.skipZeroOrMore()
.lBrace()
  .assign({leftName:'?name'})
  .or()
  .variableDeclaration({leftName:'?name'})
  .or()
  .functionDeclaration({name:'?name'})
.rBrace()
.skipZeroOrMore()
.state({lookup:{
      '?name': '?nameAddr',
      '$\_$global.?name' : '?nameAddr'
    }})
\end{lstlisting}

\subsubsection{Discussion}
%TODO
We conclude that JS-QL is capable of expressing a policy for detecting global namespace pollution, and that the resulting queries are more verbose and explicit than their equivalent in GateKeeper. This is because GateKeeper has a database of points-to analysis information available, whereas JS-QL has to specify a lookup manually.

\subsection{Script inclusions}
\label{subsec:ScriptInclusion}


A well known exploit in JavaScript environments is \textit{heap spraying}~\cite{HeapSpraying}. This is an attacking technique that can eventually even compromise a user's system. In short, heap spraying arranges the layout of the heap by allocating a vast amount of carefully-chosen strings, installing a certain sequence of bytes at a predetermined location in the memory of a target. When this is achieved, the exploit is triggered and a script is executed, possibly compromising the victims system. Such an agressive attack can be instantiated on the victim's computer by simply including a malicious script. To prevent this, a developer can write a policy which detects all script inclusions. Regular script inclusions through \texttt{<script></script>} tags can be detected by hand. Javascript however also allows programmers to write arbitrary HTML code by using the \texttt{document.write} function or similar functions (e.g. \texttt{document.writeln}). Listing \ref{lst:ScriptInclusion} gives an example of malicious script inclusions.

\begin{lstlisting}[label={lst:ScriptInclusion},language=JavaScript,caption=Script inclusion example,mathescape=true]  % float=t?

var evilScript;
var scripts = ["<script>bad1</script>","<script>bad2</script>"];

for(var i = 0; i < scripts.length; i++){
  evilScript = scripts[i];
  document.write(evilScript); //Script inclusion
}

var o = {};
o.f = document.writeln;
o.f("<script>bad3</script>"); //Script inclusion
\end{lstlisting}

\subsubsection*{GateKeeper policy}

The policy for detecting script inclusions can be written with only a few lines of datalog in GateKeeper, as depicted in listing \ref{lst:Policy3GK}. What needs to be detected are the calls to \texttt{document.write} and similar methods, even when they are aliased. This is important because scripts containing attacks are often obfuscated. \texttt{DocumentWrite(i)} first looks for the address \texttt{d} on the heap which points to the global \texttt{document} object. Next, the location of the property \texttt{write/writeln} of that object is reified in variable \texttt{m}. This is also an address on the heap. The last step is to find all call sites \texttt{i} that point to that same address on the heap. 

\begin{lstlisting}[label={lst:Policy3GK},language=Prolog,caption=Policy 3 in GateKeeper,mathescape=true]  % float=t?

DocumentWrite(i) :- GlobalSym("document",d),
                    HeapPtsTo(d,"write",m),
                    Calls(i,m).

DocumentWrite(i) :- GlobalSym("document",d),
                    HeapPtsTo(d,"writeln",m),
                    Calls(i,m).
\end{lstlisting}


\subsubsection*{JS-QL policy}

JS-QL can also express the policy listed in \ref{lst:Policy3GK}. The approach we take first skips zero or more states in the JIPDA graph. We specify that we then want to find a function call with the name of the function bound to metavariable \texttt{?name}. In order to know to which address the called function points in the store, we look it up and bind the address to \texttt{?addr} in the lookup-clause of the \texttt{fCall} predicate. Finally we also match the address of \texttt{document.write/document.writeln} to the same \texttt{?addr} metavariable, filtering out all function calls that do not point to this address.

The analysis that we use is context-sensitive and Javascript is lexically scoped. This implies that we need to explicitly specify that we are looking for the address of the \textit{global} \texttt{document.write} object. If we did not do this and the user has defined an object with the name ``document'' and a property ``write'' or ``writeln'' inside the scope of the current state in the graph, we would get the address of that object instead of the global object. \texttt{\_global} is the JS-QL keyword indicating that we are looking up an address in the global namespace, as depicted in listing \ref{lst:Policy3JSQL}.

\begin{lstlisting}[label={lst:Policy3JSQL},language=JavaScript,caption=Policy 3 in JS-QL,mathescape=true]  % float=t?

G.skipZeroOrMore()
.lBrace()
.fCall({
  name: '?name',
  lookup:{
    '?name'   : '?addr',
    '$\_$global.document.write': '?addr',
    }
})
.or()
.fCall({
  name: '?name',
  lookup:{
    '?name'   : '?addr',
    '$\_$global.document.writeln': '?addr',
    }
})
.rBrace()
\end{lstlisting}

\subsubsection*{Discussion}
Although the example demonstrates that the JS-QL query is more verbose than its GateKeeper counterpart, we conclude that we are able to express policies for detecting script inclusions.

%GK is flow insensitive, mijn vb gaat meer vinden

\subsection{Conclusion}
 In this section we expressed 3 security-related policies in the GateKeeper language and JS-QL. As table \ref{tab:GKJSQL} indicates, all security vulnerabilities expressed in GateKeeper were also expressible in JS-QL. Gatekeeper excels in writing concise policies to detect certain individual properties of a program. It is however difficult to express a policy which finds a sequence of properties in a program. JS-QL does not have this limitation. The language is designed to match states along an abstract state graph. While it can also express individual properties of a program such as calls of a certain method, it is also capable of finding complex patterns. Two other features that JS-QL offers and GateKeeper lacks is filtering and defining extra properties. It would be very cumbersome to write a policy in GateKeeper to find all function calls to methods that take more than four arguments, which can be considered as a code smell~\cite{MaintainableSoftware}. JS-QL provides the \texttt{properties} and \texttt{filters} constructs to express this.

 \begin{table}[!htb]
  
  \begin{center}
  
    \begin{tabular}{ | l || l | l | l |}
    \hline
    Language & Policy 1 & Policy 2 & Policy 3 \\ \hline
    Gatekeeper & \cmark & \cmark & \cmark \\ \hline
    JS-QL & \cmark & \cmark & \cmark \\ \hline
    \end{tabular}
    \caption*{Legend: \cmark: Fully expressible}
    \caption{Expressiveness in JS-QL and GateKeeper}\label{tab:GKJSQL}
  \end{center}
\end{table}

 We argue that our language is more expressive since we are able to express sequences and extra properties/filters for example, increasing the flexibility of policies. GateKeeper on the other hand is less verbose in most situations. This is because we have to express everything we want to detect inside the constructs of JS-QL (like \texttt{state(\{\dots\})}). Data flow analysis happens behind the scenes in GateKeeper, whereas JS-QL has to do the checks for aliasing in the language itself. An example can be seen in \ref{subsec:ScriptInclusion}, where we have to explicitly match the address of the called function to the address of \texttt{document.write}. This matching happens internally in Gatekeeper.


\section{The PidginQL language}
\label{sec:ValidationPidginQL}

In this section we express 3 policies originally presented in Pidgin~\cite{PidginQLTechReport}. Pidgin presents a query language, PidginQL, that queryies,a program dependence graph. This type of graph is different from the flow graph generated by JIPDA because it only depicts dependencies between program statements, rather than modelling the whole execution of a program. 

\subsection{Only CMS administrators can send a message to all CMS users}
\label{subsec:CMSAdmin}
%Context uitleg
In a scenario where not only administrators can broadcast messages, a regular user with bad intentions could easily take advantage of this situation to cause harm to the system. A CMS application for instance with a decent size of users could be exploited by sending a message to all users, asking them to provide with sensitive information, such as their password. When the attacker provides a reason to the victims convincing them to send their password, he could possibly compromise the contents of the victim's account. This behaviour is undesirable, thus we need a policy which prevents regular users from sending such messages.

\subsubsection*{Pidgin policy}

The policy described in Pidgin that addresses this issue can be found in listing \ref{lst:Policy4PidginQL}. First, all nodes that are entries of the \texttt{addNotice} method are searched for and stored in a variable. \texttt{addNotice} is the method that sends messages to all users. Next, all points in the PDG are found that match a return node of the \texttt{isCMSAdmin} method with a return value which is truthy. In order to know if there exists some path in the graph where \texttt{addNotice} is called when the return value of \texttt{isCMSAdmin} is false, all paths between the nodes in \texttt{addNotice} and \texttt{isAdmin} are removed from the graph for all paths where \texttt{isAdmin} is true. Finally, the intersection of the nodes in this 'unsanitized' graph and the nodes in the \texttt{sensitiveOps} argument, which represents a broadcast in this case, is taken. When this intersection is not empty, we can assume that there is a violation of the policy in the remainder of the graph. This last part is exactly what the \texttt{accessControlled} method does.

%AccessControlled = let accessControlled(G, checks, sensitiveOps) = G.removeControlDeps(checks) ∩ sensitiveOps is empty
\begin{lstlisting}[label={lst:Policy4PidginQL},language=JavaScript,caption=Policy 4 in PidginQL,mathescape=true]  % float=t?

let accessControlled(G, checks, sensitiveOps) = 
    G.removeControlDeps(checks) $\cap$ sensitiveOps is empty

let addNotice = pgm.entriesOf("addNotice") in
let isAdmin   = pgm.returnsOf("isCMSAdmin") in 
let isAdminTrue = pgm.findPCNodes(isAdmin,TRUE) in
                pgm.accessControlled(isAdminTrue, addNotice)
\end{lstlisting}

\subsubsection{JS-QL policy}

When attempting to write a similar query in JS-QL, we need to define the problem in terms of control flow: ``There must be no path between the returns of \texttt{isCMSAdmin} when the return value is false, and a call of the \texttt{addNotice} method.'' With abstract interpretation, a value can be both true and false, which is why we have to inspect the nodes in the state graph. When looking at a conditional (like an \texttt{IfStatement}), we can determine whether the true of false branch has been taken by comparing the first node of the branches with the alternate/consequent of the conditional. This can be seen on lines 2 and 6 of listing \ref{lst:Policy4JSQL}, where the \texttt{?alt} variable of the \texttt{IfStatement} gets matched with one of the successive states, ensuring that that state is the beginning of the false branch. We bind the context of the branch state to \textit{?kont} and the stack to \textit{?lkont}. The next time we find a state with the same context and stack, we know that the end of the branch has been reached. Lines 8-9 indicate that we only wish to find the calls to \texttt{addNotice} before the end of the branch.

\begin{lstlisting}[label={lst:Policy4JSQL},language=JavaScript,caption=Policy 4 in JS-QL]  % float=t?

G.skipZeroOrMore()
.ifStatement({alt:'?alt'})
.skipZeroOrMore()
.fCall({name:'isCMSAdmin'})
.skipZeroOrMore()
.state({node:'?alt', kont:'?k',lkont:'?lk'})
.not().endIf({kont: '?k', lkont:'?lk'}).star()
.fCall({name:'addNotice'})
\end{lstlisting}

\subsubsection*{Discussion}
While this policy finds all cases where \texttt{isCMSAdmin} is false, it will not detect calls to \texttt{addNotice} outside this test. We can solve this by finding all calls to \texttt{addNotice}, but this leads to false positives. The situation would be improved if a means to express the \textit{XOR} relation between results of the JS-QL policies existed. If we had this kind of mechanism at hands, we could search for all calls to \texttt{addNotice} and the calls to \texttt{addNotice} that happen in the true branch of \texttt{isCMSAdmin} and remove all states that occur in both results. The result of this removal would then contain only the violations of the policy. Currently, no operation for combining queries is supported, as this would require an other layer of abstraction over query results. Although possible, the combining of queries is out of the scope of this dissertation.

\subsection{Public outputs do not depend on a user's password, unless it has been cryptographically hashed}


Users want to prevent sensitive information from leaking to other users. It is therefore not desirable that sensitive information about passwords is leaked in any way to public outputs. This leak of information can be implicit. Imagine a situation where a malicious piece of code checks if the length of the password is larger than 5. If the condition is true the output will display 1, otherwise the output is 0. This also reveals information about the password, and thus should be treated as a violation. The name for this kind of information flow is \textit{implicit flow}.

\begin{lstlisting}[label={lst:PWDepends},language=JavaScript,caption=The output depends on the password example,mathescape=true]  % float=t?

var password = getPassword();
//computeHash(password);
var message;
if(password.length() > 5){
  message = 1;
  print(message);
}
else{
  message = 0;
  print(message);
}
\end{lstlisting}

\subsubsection*{Pidgin policy}

Since PidginQL works on the the dependence graph of a program, the 'depends' relation is easily checked. In the graph there must be no path between the retrieval of the password and an output, unless \texttt{computeHash} was called. \textit{Declassification} happens when calling this method, which means that from then on the password is sanitized and ready to flow to an output. The policy in listing \ref{lst:Policy5PidginQL} displays how this is expressed in the PidginQL language.

\begin{lstlisting}[label={lst:Policy5PidginQL},language=JavaScript,caption=Policy 5 in PidginQL,mathescape=true]  % float=t?

let passwords = pgm.returnsOf("getPassword") in 
let outputs   = pgm.formalsOf("writeToStorage") $\cup$
                pgm.formalsOf("print") in
let hashFormals = pgm.formalsOf("computeHash") in
pgm.declassifies(hashFormals, passwords, outputs)
\end{lstlisting}

\subsubsection*{JS-QL policy}

The scenario for which we write a policy in JS-QL is as follows: An output depends on the password when the password is used in a conditional expression. In one or more of the branches of this conditional expression an output function is then called. The example code on which we test our policy is listed in listing \ref{lst:PWDepends}. We look for a state in the graph where the password is returned, and we store the address in \texttt{?addr}. The program then continues for some states in which the \texttt{computeHash} method is \textit{not} called with the password as an argument (lines 3-16). We then match a state representing a conditional node, in this case an \texttt{IfStatement} for which we bind the true branch to \texttt{?cons} and the false branch to \texttt{?alt}. 

Note that in the JIPDA abstract state graph, all evaluation steps are visible in the graph. This gives us an opportunity to check if somewhere in the condition of the conditional the password is used before the actual branching happens. The \texttt{variableUse} predicate on line 19 performs this check. It matches any state in which a variable is used. The declarative nature of the predicates allows us to pass the address of the variable as a metavariable, so that we can specify that we only want to match the uses of the variable whose address is alread captured in \texttt{?addr}. When this results in a match, we know that the variable has been used in the evaluation of the condition of the conditional. 

Finally, we proceed by checking if an output function (\texttt{print} in this case) is called \textit{inside} one of the branches of the conditional. We do this by matching the nodes of states to the already bound \texttt{?cons} and \texttt{?alt}. A match indicates that that state is the beginning of the true branch or false branch respectively. For these branches, we capture the context and current stack in two additional metavariables \texttt{?k} and \texttt{?lk}. These will be needed on line 26 to indicate that we want to find the call to \texttt{print} \textit{before} the branch ends. This policy, found in listing \ref{lst:Policy5JSQL}, can be made more general by writing a predicate which captures all conditionals instead of just \texttt{IfStatement}s.

\begin{lstlisting}[label={lst:Policy5JSQL},language=JavaScript,caption=Policy 5 in JSQL,mathescape=true]  % float=t?

G.skipZeroOrMore()
.procedureExit({functionName:'getPassword', returnAddr : '?addr'})
.not()
  .state({
    node:{  
      expression: {
          callee: { name:'computeHash' },
          arguments: '?args'
      }
    },
    properties: {
      '?arg' : prop('memberOf', '?args'),
      '?firstName': '?arg.name'
    },
    lookup:{ '?firstName' : '?addr' }
  }).star()
.ifStatement({cons:'?cons', alt:'?alt'})
.skipZeroOrMore()
.variableUse({addr:'?addr'})
.skipZeroOrMore()
.lBrace()
  .state({node:{this:'?cons'}, kont:'?k', lkont:'?lk'})
  .or()
  .state({node:{this:'?alt'}, kont:'?k', lkont:'?lk'})
.rBrace()
.not().state({kont:'?k', lkont:'?lk'}).star()
.fCall({name: 'print'})
\end{lstlisting}
 
\subsubsection*{Discussion}
Expressing dependencies in JS-QL is challenging. However, we were able to fully express the PidginQL policy for checking if an output depends on a user password. We can conclude that the JS-QL policy is more verbose than its PidginQL counterpart, but it is also more flexible in its notation.
%We do have to admit that it is nearly impossible to express a policy which checks all dependencies, as our query languages works on an underlying abstract state graph instead of a program dependence graph. We illustrate this in the following scenario: Instead of using \texttt{password.length > 5} in the conditional, the length is stored in another variable \texttt{length}. We won't detect violations when the following expression is used as a condition: \texttt{length > 5}, since we can't mark the length 


%TODO: Conclusie?

\subsection{A database is opened only after the master password
is checked or when creating a new database}
\label{subsec:DBOpen}


A database may contain sensitive information, so it is important that only authorized people can access this information. it therefore is necessary to restrict access to the database, unless upon creation or when the correct credentials can be presented. 

\subsubsection*{Pidgin policy}

The PidginQL query in listing \ref{lst:Policy6PidginQL} describes the query pattern in pseudocode. All nodes corresponding to checks of the master password are stored in the \texttt{check} variable. Lines 2 and 3 remove these nodes from the graph when the condition is true (i.e. when the master password is correct). Finally, the nodes where the creation of a new database occurs are also deleted from the graph, resulting in a graph which consists of only nodes that represent the opening of the database. If the graph is empty, then no violations are found.

\begin{lstlisting}[label={lst:Policy6PidginQL},language=JavaScript,caption=Policy 6 in PidginQL,mathescape=true]  % float=t?

let check = (all checks of the password)
let checkTrue = pdg.findPCNodes(check, TRUE) in
let notChecked = pdg.removeControlDeps(checkTrue) in
let newDB = (method to create database)
let openDB = (method called to open the database)
notChecked.removeNodes(newDB) and openDB is empty
\end{lstlisting}

\subsubsection*{JS-QL policy}

We created 2 JS-QL policies that provide full coverage for the problem that is presented in this section, listed in listing \ref{lst:Policy6JSQL}. The problem can be alternatively stated as follows: Find all calls to \texttt{openDatabase} that are not inside the true branch of a conditional that checks if the master password is correct. When described like this, the vulnerability is much more intuitive to express in JS-QL. The policy can be split up in two parts: The first part will skip to an \texttt{IfStatement} of which we bind the true branch to \texttt{?cons}, as in the previous example. We then again check if the condition of that statement uses the \texttt{isMasterPassword} to verify the correctness of the password. We want to look into all states for which this condition does not hold, which is described on line 7. In this case all calls to \texttt{openDatabase} are prohibited, except inside the \texttt{newDatabase} function. 

This policy catches all violations \textit{after} the first matching \texttt{IfStatement}. That is why there is the need for a second part in the policy, depicted on line 16. The detection of all calls to the \texttt{openDataBase} function completes this policy, but adds as a side effect that it will add false positives. These false positives will be the calls to \texttt{openDatabase} that occur when the master password is correct. This confirms the need for the \textit{XOR} relation, as described in the previous section. 

\begin{lstlisting}[label={lst:Policy6JSQL},language=JavaScript,caption=Policy 6 in JS-QL,mathescape=true]  % float=t?

G.skipZeroOrMore()
.lBrace()
  .lBrace()
    .ifStatement({cons:'?cons'})
    .skipZeroOrMore()
    .fCall({name:'isMasterPassword'})
    .not().state({node:'?cons'}).star()
    .beginApply({name:'?name', lkont:'?lk', kont:'?k',
                 filters:[
                  cond('!==', '?name', 'newDatabase')
                 ]})
    .not().endApply({lkont:'?lk', kont:'?k'}).star()
    .fCall({name:'openDatabase'})
  .rBrace()
  .or()
  .fCall({name:'openDatabase'})
.rBrace()
\end{lstlisting}

\subsubsection*{Discussion}
This policy was challenging to express in JS-QL. Although able to detect all violations, the JS-QL policy will result in false positives. At the moment, it is not possible to express a JS-QL query for this policy which only detects violations without false positives.

\subsection{Conclusion}
In this section we expressed 3 security vulnerabilities in the PidginQL language and JS-QL. Table \ref{tab:PidginQLJSQL} indicates that not all three policies were easily expressible. We are able to express all 3 policies in JS-QL, but 2 of them will have results containing false positives. These two policies each consisted of two separate queries. If we wish to attain a resultset only containing violations and no false positives, we could take the exclusive disjunction of the resultsets of these separate queries. 

The PidginQL language is best at expressing policies that deal with the dependencies between nodes in their program dependence graph. This type of graph is very powerful to check the control and data flow between two parts of code~\cite{PDG}, but it is more difficult to use it to detect more general properties about a program. For JS-QL, it is the other way around. Our approach allows us to detect a wide range of general and complex properties about a program, but it sometimes has troubles detecting dependencies between states with only one policy. PidginQL may be powerful in finding dependencies as described above, it does however not return much meaningful information about the found violations. Where JS-QL returns all violating nodes marked in a GUI, PidginQl just indicates whether there are violations or not. It doesn't specify which nodes are violating the policy.

 \begin{table}[!htb]
  
  \begin{center}
  
    \begin{tabular}{ | l || l | l | l |}
    \hline
    Language & Policy 4 & Policy 5 & Policy 6 \\ \hline
    PidginQL & \cmark & \cmark & \cmark \\ \hline
    JS-QL & \omark & \cmark & \omark \\ \hline
    \end{tabular}
    \caption*{Legend: \cmark: Fully expressible, \omark: Expressible with false positives}
    \caption{Expressiveness in JS-QL and Pidgin}\label{tab:PidginQLJSQL}
  \end{center}
\end{table}

Another restriction in PidginQL is that there is no way to reason about the internals of a state in the graph. Our language allows the programmer to query information in the graph on the level of each state. We can dig inside a state at any time and specify the information we wish to obtain in some user-declared metavariables. This is not possible in PidginQL. This expressiveness and flexibility brings along that JS-QL queries and policies will often be more verbose.

While JS-QL can be used for many different domains, PidginQL is especially strong in the domain of querying for dependencies between nodes.

\section{The ConScript language}
\label{sec:ValidationConscript}

In this section we express 3 security vulnerabilities originally presented in ConScript~\cite{ConScript}. ConScript is a client-side advice implementation for security. The language allows the hosting page to express fine-grained application-specific security policies that are enforced at runtime.

\subsection{No string arguments to setInterval, setTimeout}


In JavaScript, \texttt{setInterval} and \texttt{setTimeout} take a callback function as a first argument that is fired after a certain interval of time. Surprisingly, a string argument can also be passed as the first argument, as indicated in listing \ref{lst:JSSetTimeout}. This allows potential attackers to pass malicious code as a string argument to \texttt{setInterval/setTimeout}, which can lead to security threats.


\begin{lstlisting}[label={lst:JSSetTimeout},language=JavaScript,caption=No string arguments to setTimeout,mathescape=true]  % float=t?

var f = function(){}
var i = 1;
var s = "stringgy"
var o = {};
setTimeout(i, interval);
setTimeout(s, interval);  //Violation
setTimeout(o, interval);
setTimeout(f, interval);
\end{lstlisting}

\subsubsection*{ConScript policy}

ConScript is an aspect-oriented advice language that is able to detect security violations such as the one depicted in listing \ref{lst:JSSetTimeout}. The aspects are written in JavaScript, which enables the programmer to make full use of the language. The ConScript language also provides a typesystem which assures that the policies are written correctly, as can be seen in listing \ref{lst:Policy7Conscript} on line 1. Lines 10-11 depict the actual registration of the advice on the \texttt{setInterval} and \texttt{setTimeout} functions. When called, the \texttt{onlyFnc} function will be triggered instead, which checks if the type of the argument is indeed of type ``function''. \texttt{curse()} has to be called within the advice function, disabling the advice in order to prevent an infinite loop. We consider this as a small hack, since it has no additional semantic value for the policy itself.

\begin{lstlisting}[label={lst:Policy7Conscript},language=JavaScript,caption=Policy 7 in ConScript,mathescape=true]  % float=t?

let onlyFnc : K x U x U -> K =
function (setWhen : K, fn : U, time : U) {
    if ((typeof fn) != "function") {
        curse();
        throw "The time API requires functions as inputs.";
    } else {
        return setWhen(fn, time);
    }
};
around(setInterval, onlyFnc); 
around(setTimeout, onlyFnc);
\end{lstlisting}

\subsubsection*{JS-QL policy}
%Policy in JS-QL
As we can not reason about actual concrete values in abstract interpretation in our approach, writing a policy that only allows strings seems more challenging. This is not the case however, because the lattice we use gives us information about the type of the value of variables. A string for example is indicated by the lattice value \texttt{\{Str\}}. We can then define a \texttt{isString} helper function which checks whether a variable \textit{may} be of type String or not. The JS-QL policy in listing \ref{lst:Policy7JSQL} uses this function to determine whether the looked up value of the \texttt{?name} variable is of type String or not. The policy looks for a call of the \texttt{setTimeout} function and binds its arguments to \texttt{?args}. \texttt{memberOf}, which creates a new substitution set for each of the elements in the list that it takes as an argument.
This allows us to inspect and check each individual argument \texttt{?arg} of the \texttt{setTimeout} function. We take the name of the argument and look up its value in the lookup clause. What remains is to filter out the string arguments, as already discussed above. This policy will only detect the actual violation on line 6 in listing \ref{lst:JSSetTimeout}.

\begin{lstlisting}[label={lst:Policy7JSQL},language=JavaScript,caption=Policy 7 in JS-QL,mathescape=true]  % float=t?

G.skipZeroOrMore()
.fCall({
  name:'setTimeout',
  arguments:'?args',
  properties:{
    '?arg' : prop('memberOf', '?args'),
    '?name': '?arg.name',
  },
  lookup:{'?name': '?lookedUp'},
  filters:[
    cond('isString', '?lookedUp')
  ]
})
\end{lstlisting}

%Bespreken
\subsubsection*{Discussion}
Both approaches are able to express the security vulnerability in a concise way. The JS-QL policy however is more readable than its ConScript counterpart, as it requires less boilerplate code and does not use type system annotations.

\subsection{HTTP-cookies only}
\label{subsec:HTTPOnly}


Servers often store state information on the client in the form of cookies. They do this to avoid the cost of maintaining session state between calls to the server. Cookies may therefore contain sensitive information that may only be accessed by the server, so it is necessary to prohibit reads and writes to the client's cookies. These are stored in the global \texttt{document.cookie} object. Listing \ref{lst:HTTPCookiesOnly} gives an example of possible violations.

\begin{lstlisting}[label={lst:HTTPCookiesOnly},language=JavaScript,caption=HTTP-cookies only example,mathescape=true]  % float=t?

var doc, cookie1, cookie2, cookie3, badFunc;
badFunc = function(){
  var bad;
  bad = document.cookie;        //Violation (read)
  return bad;
}

cookie1 = document.cookie;      //Violation (read)
doc = document;
cookie2 = doc.cookie;           //Violation (read)
cookie3 = badFunc();            //Violation (read)
document.cookie = {value:"bad"} //Violation (write)
\end{lstlisting}


\subsubsection*{ConScript policy}

In ConScript, the policy can be enforced with only a few lines of code. Listing \ref{lst:Policy8Conscript} wraps reads and writes of the "cookie" field of \texttt{document} in the \texttt{httpOnly} advice. An error is thrown when a violation against this policy is encountered.

\begin{lstlisting}[label={lst:Policy8Conscript},language=JavaScript,caption=Policy 8 in ConScript,mathescape=true]  % float=t?

let httpOnly:K->K=function(_:K){ 
    curse(); 
    throw "HTTP-only cookies"; 
};
around(getField(document, "cookie"), httpOnly); 
around(setField(document, "cookie"), httpOnly);
\end{lstlisting}


\subsubsection*{JS-QL policy}

Writing an equivalent JS-QL policy proves to be more verbose. The reason for this is that we only work with our own embedded DSL to query the information in the JIPDA graph. While the \texttt{getField} and \texttt{setField} in \ref{lst:Policy8Conscript} handle the lookup of the address of \texttt{document.cookie}, we have to manually specify that we want to store the address in metavariable \texttt{?cookieAddr} and try to match it with the address of the \texttt{?name} metavariable, which we assign to the same metavariable \texttt{?cookieAddr} to filter out variables with a different address. The JS-QL policy in \ref{lst:Policy8JSQL} specifies that it only detect writes (the first \texttt{assign} predicate) and reads (the \texttt{procedureExit} and second \texttt{assign} predicate) of the \texttt{?name} variable which points to the address of the global \texttt{document.cookie} object. The \texttt{assign} predicate matches the left or right name of the assignment and performs a lookup. The \texttt{procedureExit} is an extra predicate which marks all returns of functions that return a value that again points to the address of the global \texttt{document.cookie} address.


\begin{lstlisting}[label={lst:Policy8JSQL},language=JavaScript,caption=Policy 8 in JS-QL,mathescape=true]  % float=t?

G.skipZeroOrMore()
.lBrace()
  .assign({leftName:'?name',
           lookup:
           {
               '_global.document.cookie' : '?cookieAddr',
               '?name'                   : '?cookieAddr' 
           }
          })
  .or()
  .assign({rightName:'?name',
           lookup:
           {
               '_global.document.cookie' : '?cookieAddr',
               '?name'                   : '?cookieAddr' 
           }
          })
  .or()
  .procedureExit({returnName:'?name',
                  lookup:
                  {
                      '_global.document.cookie' : '?cookieAddr',
                      '?name'                   : '?cookieAddr'  
                  }
                })
.rBrace()
\end{lstlisting}

\subsubsection*{Discussion}
The JS-QL policy for detecting access to cookies is more verbose than the policy written in ConScript. This is because ConScript has access to the getter and setter methods of variables, whereas JS-QL can only reason about the information which is contained in the abstract state graph. JS-QL thus needs to manually look for access violations to \texttt{document.cookie}, instead of just checking if a getter or setter of that variable is called.

\subsection{Prevent resource abuse}
Malicious scripts can prevent parts of a program to be accessible by users. A website or plugin can exploit resources by consecutively displaying popup windows. This is a form of resource abuse, namely the abuse of modal dialogs. This can be prevented by prohibiting calls to functions that create these resources. 

\subsubsection*{ConScript policy}

The ConScript policy is similar to the policy discussed in section \ref{subsec:HTTPOnly}. Calls to \texttt{prompt} and \texttt{alert} are wrapped in an advice which throws an error. Listing \ref{lst:Policy9Conscript} shows the source code of the policy.

\begin{lstlisting}[label={lst:Policy9Conscript},language=JavaScript,caption=Policy 9 in ConScript,mathescape=true]  % float=t?

let err : K -> K = function () { 
    curse(); 
    throw 'err'; 
}); 
around(prompt, err); 
around(alert, err);
\end{lstlisting}


\subsubsection*{JS-QL policy}

Wrapping an advice around a function to detect calls to that function can be used to prevent the invocation of that function. To find function invocations in JS-QL, one just has to write a policy consisting of a \texttt{fCall} predicate. This predicate has to be configured to return all relevant information we need about the function call. In listing \ref{lst:Policy9JSQL} we can see that a function call (AST) node contains fields for its \texttt{procedure} and its \texttt{arguments}. We bind these to \texttt{?proc} and \texttt{?args} respectively. We then further define an extra metavariable \texttt{?name} in the \texttt{properties} clause of the predicate, which maps to the name of the earlier defined \texttt{?proc}. Once we have the information about the function that is invoked, we can look up its address and compare it to the address of the global \texttt{alert} (or \texttt{prompt}) function. When these are equal, the substitutions for the detected function call will be added to the results.

\begin{lstlisting}[label={lst:Policy9JSQL},language=JavaScript,caption=Policy 9 in JS-QL,mathescape=true]  % float=t?

G.skipZeroOrMore()
.fCall({
  procedure:'?proc',
  arguments:'?args',
  properties:{
    '?name' : '?proc.name'
  },
  lookup:{'?name': '?alertAddress',
          '_global.alert': '?alertAddress'}
})
\end{lstlisting}

\subsubsection*{Discussion}
We conclude that JS-QL is capable of expressing a policy for detecting resource abuse, and that the resulting queries are more about as verbose as their equivalent in ConScript. The result of the JS-QL query returns the exact positions in the program where a violation occurs, whereas ConScript only throws an error if an actual violation is encountered.

\subsection{Conclusion}

In this section we expressed 3 security vulnerabilities in the ConScript language and JS-QL. It is not straigforward to compare both approaches, as ConScript checks for policy violations using dynamic analysis. We can however compare the expressiveness of the policies written in each language. Table \ref{tab:CSJSQL} shows that we are able to express all 3 ConScript policies in JS-QL.

The ConScript language applies advices around function calls, changing the behavior of the program if the function call was prohibited. The aspect-oriented approach allows ConScript to specify what actions that need to be taken when a violation is detected. We can not express this in JS-QL, but this is also not necessary since we detect violations at compile-time, rather than at runtime. Field accesses can also be expressed as function calls (\texttt{getField} and \texttt{setField} in listing \ref{lst:Policy8Conscript}), so ConScript can reason about getting and setting values as well. JS-QL can also reason about these things, but it has access to a lot more information thanks to the abstract state graph.
 
\begin{table}[!htb]
  
  \begin{center}
  
    \begin{tabular}{ | l || l | l | l |}
    \hline
    Language & Policy 7 & Policy 8 & Policy 9 \\ \hline
    Gatekeeper & \cmark & \cmark & \cmark \\ \hline
    JS-QL & \cmark & \cmark & \cmark \\ \hline
    \end{tabular}
    \caption*{Legend: \cmark: Fully expressible}
    \caption{Expressiveness in JS-QL and ConScript}\label{tab:CSJSQL}
  \end{center}
\end{table}

The advice functions written in ConScript have full access to the JavaScript language, making them very flexible in behaviour. By using JavaScript instead of a DSL, the policies themselves are also quite verbose, since for each policy a JavaScript function has to be created. This does allow users of ConScript to define properties and filters, as in JS-QL. However, the advice approach limits ConScript to detect only function calls, which certainly is a limitation because it reduces expressiveness. Querying for multiple sequential lines of code is also hard to do in ConScript. Where a JS-QL policy could easily be written to detect a function call to method \texttt{X} after reading variable \texttt{Y}, Conscript has to define variables that function as a ``boolean''. The variable will be set to true when \texttt{Y} is read. The advice around \texttt{X} then has to check the value of \texttt{Y} before deciding what action to perform.

We argue that JS-QL queries are more expressive when it comes down to the detection of different kinds of program states. The language also proves flexible in terms of specifying properties and filters, but is not as flexible as ConScript because the latter has full access to the JavaScript language once an advice is triggered. Both languages are quite verbose because of the expressiveness they provide.


\section{Evaluation}
\label{sec:ValidationEvaluation}
%INTRO
% We hebben 9 policies besproken, nu gaan we onze taal evalueren adhv Advantages en limitations
We evaluated the JS-QL language by expressing 9 different security vulnerabilities originating from 3 different papers. This section evaluates the tool presented in the dissertation by discussing the advantages and limitations of the query language.

\subsection{Advantages}

\subsubsection*{Granularity of queries and policies}
A key advantage of the JS-QL tool is the ability for programmers to define queries and policies as general or specific as they want. Starting from the \texttt{state} predicate, a user can express complex patterns that fit his needs and wrap them in a self-named predicate. Flexibility is key in these predicates since the user can specify which properties he exposes through the predicate. These properties can then be queried by passing metavariables as arguments, which will later be bound when a match is found. Literals and metavariables that are already bound act as filters for the predicates, as in any declarative language.

\subsubsection*{Negation}
Negation can be useful when expressing actions that should not happen at a certain moment in a query. This was illustrated in section \ref{subsec:CMSAdmin}, where a function call needed to be detected before the end of a conditional branch. JS-QL, in contrast to many other query languages, offers this expressiveness, albeit in a limited way. 

\subsubsection*{Flexibility}
The JIPDA graph contains states with information of arbitrary depth. Therefore, the tool has to provide access to these levels of information. This flexibility again opens up opportunities because we are not bound to one particular graph type. Hypothetically, all types of graphs that contain information in its edges and nodes can be used in the tool with little to no modification of the tool itself. Only a reification layer of the new graph should be provided, mapping the states of the graph to the format our tool uses.

\subsubsection*{Recursion}
Another non-trivial feature of the JS-QL tool is the possibility to recursively define queries. This type of queries are especially useful when one wants to follow a trace of information starting at a certain point. For example, an interesting use for recursive queries is to trace all aliases of a certain variable. The result then shows all states in the graph where the original variable is aliased. Along with the marked nodes in the graph, a table containing all substituted metavariables is also displayed. We believe this representation makes the results comprehensive for users.

\subsection{Limitations}

Other approaches might modify the graph by deleting states and edges to obtain a new graph. This new graph then only consists of information needs to be reasoned about. Our tool currently does not provide this functionality. 

Another feature that would amplify the expressive power of the tool would be some means to combine results of multiple queries, such as the use of logical arithmetics. Expressing the disjunction or conjunction of two queries would greatly improve the expressiveness of JS-QL. An example of this was given in subsections \ref{subsec:CMSAdmin} and \ref{subsec:DBOpen}. 


Although negation is already supported, it only works for single \texttt{state}s. We would also add to the expressiveness of the language if we were unrestricted while expressing negation. This is a topic for future research.

\subsection{Performance}
The time to generate the abstract state graph depends on the size of the input program, and the time needed by the solver algorithms depends on the size of the query (i.e. number of pattern states). All of the vulnerabilities expressed in this chapter could be checked in under 3 seconds. For this dissertation however, performance is of lesser importance.

\subsection{Conclusion}
%OUTRO

The combination of abstract state graphs and regular path expressions prove to be an effective means to obtain program information and define security policies. We validated our tool by expressing a range of different security vulnerabilities in the JS-QL language. We discussed the differences in our language and three other languages for expressing security vulnerabilities. By evaluating our tool, we identified the advantages and limitations of our approach. We can conclude that the JS-QL tool can be used to express a wide variëty of security vulnerabilities in a readable and flexible way, but that it is still limited in expressiveness for certain types of policies, such as policies for detecting dependencies between two states.
  

%  \begin{table}\begin{center}
%    \begin{tabular}{ | l || l | l | l |}
%    \hline
%    Language   & Expressiveness & Flexibility & Verbosity \\ \hline
%    JS-QL      &      ++        &     +++     &    +++    \\ \hline
%    GateKeeper &      ++        &     ++      &    ++     \\ \hline
%    PidginQL   &      ++        &     +       &    +      \\ \hline
%    ConScript  &      +         &     +++     &    +++    \\ \hline
%    \end{tabular}
%    \caption{Evaluating properties of the query languages}\end{center}
%  \end{table}

