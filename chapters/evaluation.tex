In this chapter we validate and evaluate the expressiveness of the JS-QL query language by expressing some existing security policies, described in other related work. We will then compare these policies in terms of expressiveness and flexibility. %TODO: Vergelijken op welke manier
We start this chapter by expressing 9 security policies distilled from 3 papers in sections \ref{sec:ValidationPidginQL}, \ref{sec:ValidationGK} and \ref{sec:ValidationConscript} respectively. Every JS-QL policy will be evaluated by comparing how well it matches the policy expressed in the original paper. Finally, in section \ref{sec:ValidationEvaluation}, we evaluate the query framework by specifying its advantages, disadvantages and limitations. We will also briefly compare the query languages presented in this chapter in terms of expressiveness, verbosity and conciseness.
%TODO: wat gaan we nog comparen?
%TODO: JAVASCRIPT SOURCE CODE ADDEN
\section{The GateKeeper language}
\label{sec:ValidationGK}

In this chapter we attempt to express 3 policies originally presented in \cite{GateKeeper}.

\subsection{Writes to prototype objects}

Many websites use bookmarklets to store user information to automate the login process, for example \cite{PrototypePoisoning}. This is a common strategy used to reduce the amount of information the user has enter every time he visits the website. An attacker website however can alter the JavaScript environment in such a way that he can steal all of this information from the user. Imagine a simple login function which checks the current location of the webpage to verify that it is on the correct webpage. The current location can be compromised by overwriting the \texttt{toString} function of the \texttt{String} object, as depicted in \ref{lst:PrototypePoisoning}. This function can be configured to always return a "good" location. In this way, the login function can be called in the environment of a malicious website, possibly leaking sensitive information.

\begin{lstlisting}[label={lst:PrototypePoisoning},language=JavaScript,caption=Prototype poisoning example,mathescape=true]  % float=t?

String.prototype.toString = function(){
    //Always return "spoofed" url
    return "www.goodwebsite.com";
}

var login = function(){
  if(document.location.toString() === "www.goodwebsite.com"){
    //leak information on untrusted website
  }
}
\end{lstlisting}

%gatekeeper doet het zo
Gatekeeper expresses policies by defining a set of rules in datalog. In order to detect writes to prototypes of builtin objects, they define the \texttt{FrozenViolation(v)} predicade, as shown in listing \ref{lst:Policy1GK}. This predicate first looks for all stores of field \texttt{v}. This field points to location \texttt{h2}, which represents the points-to address for variables. Only writes to builtin objects are infringements of the policy, which implies that \texttt{h2} has to point to a field of of one of these objects. This is expressed as follows: In \texttt{BuiltInObjects(h)}, \texttt{h} points to the heap location of a builtin object. The \texttt{Reaches(h1,h2)} predicate makes sure that the field that was stored reaches the builtin object directly or indirectly, by recursively checking if one of the properties of the builtin object has a field pointing to the stored field.

\begin{lstlisting}[label={lst:Policy1GK},language=Prolog,caption=Policy 1 in GateKeeper,mathescape=true]  % float=t?

Reaches(h1,h2) :- HeapPtsTo(h1,_,h2).
Reaches(h1,h2) :- HeapPtsTo(h1,_,h3),
                  Reaches(h3,h2).

FrozenViolation(v) :- Store(v,_,_),
                      PtsTo(v,h2),
                      BuiltInObject(h1),
                      Reaches(h1,h2).

% Specify all built in objects
BuiltInObject(h) :- GlobalSym("String", h).
BuiltInObject(h) :- GlobalSym("Array", h).
% ...

GlobalSym(m,h) :- PtsTo("global", g),
                  HeapPtsTo(g,m,h).

\end{lstlisting}

%ik doe het zo (geef voorbeeld voor ééntje, zeggen dat we een compound query hebben gemaakt voor om te bundelen)
Writing this policy in JS-QL is easy. To ease the work for the programmer, we augmented the Jipda-nodes corresponding with \texttt{MemberExpression}s two extra fields: \texttt{mainObjectName} and \texttt{properties}, representing the root object and the property-chain array that was accessed respectively. An example: for \texttt{o.x.y.z}, \texttt{o} would be the \texttt{mainObjectName}, and \texttt{[x,y,z]} would be the array \texttt{properties} which represents the properties that were chained. Listing \ref{lst:Policy1JSQL} depicts the JS-QL query to efficiently express this policy. Note that the filter on lines 10-12 can be omitted. This filter simply indicates that we only want to detect writes to the \texttt{prototype} property of the \texttt{String} object. When this is omitted, we will detect all writes to this object.

\begin{lstlisting}[label={lst:Policy1JSQL},language=JavaScript,caption=Policy 1 in JS-QL,mathescape=true]  % float=t?

G.skipZeroOrMore()
.state({
  node:{
    expression:{
      left:{
        properties: '?props',
        mainObjectName: 'String'
      }
    }
  },
  filters:[
    cond('contains', '?props', 'prototype')
  ]
})

\end{lstlisting}

This example JS-QL policy only detects writes to the \texttt{String} object. We wrote a compound policy \texttt{writeToBuiltinObjectPrototype} to detect writes to all builtin objects' prototype property. The code for this policy can be found in listing \ref{lst:WriteToBuiltinObjectPrototype} in the appendix. This policy is just the disjunction of states similar to the state in listing \ref{lst:Policy1JSQL}, with the only difference in the \texttt{mainObjectName} property, which corresponds to a different builtin object name.
%TODO: bespreken

\subsection{Global namespace pollution}

Working in a JavaScript environment often involves the inclusion of multiple (third-party) scripts. These scripts offer instant access to functionality which would be tiresome to implement for every project yourself. Some of these scripts are written by other parties, so one can't be sure that they follow the same coding guidelines as he does. Inexperienced programmers might not be aware of the JavaScript namespacing patterns \cite{JSNamespacing}. This leaves an open window for a phenomenon called "global namespace pollution". Defining variables in the global scope in JavaScript can lead to unanticipated behaviour of the program when another script defines a global variable with the same name.

Preventing stores to the global object (i.e. in the global scope) can be enforced through a simple two-lined GateKeeper policy. GateKeeper handles the global object explicitly by defining a variable \texttt{global}. Global variables can then be simulated as fields of this object. Note that JIPDA does this in a similar way. A policy to detect global stores can then be defined as in \ref{lst:Policy2GK}: The global object variable is located on address \texttt{g}. Every field store \texttt{h} that points to a field of \texttt{g} will then be detected by the \texttt{GlobalStore} policy.

\begin{lstlisting}[label={lst:Policy2GK},language=Prolog,caption=Policy 2 in GateKeeper,mathescape=true]  % float=t?

GlobalStore(h) :- PtsTo("global",g),
                  HeapPtsTo(g,_,h).
\end{lstlisting}

We could write a similar policy in JS-QL that would also look if the address of the variable points to the global object. However, this is more difficult in our system. Not because of any language restrictions, but because of the nature of JIPDA. When a variable or function gets declared or when a variable is assigned to, the right-hand side first has to be evaluated. This is also reflected in the JIPDA graph. Only when the expression is evaluated, the store and environment are modified to contain the recently evaluated information. What this means is that the allocation address for newly created variables isn't yet available in the states we query on lines 3,5 and 7 in listing \ref{lst:Policy2JSQL}. We remedy this by looking a bit further down the graph, more specifically in the states where this information \textit{IS} available. The policy goes as follows: After skipping to an assignment or a declaration of a function or variable, we bind the name the variable's or function's name to metavariable \texttt{?name}. We then again skip some nodes until we find a state where the address of \texttt{?name} is available and bind it to \texttt{?nameAddress}. Finally, we search for the variable or function with the same name in the global object and also bind it to \texttt{?nameAddr}, which filters the resulting substitutions to only contain information about globally declared objects.

\begin{lstlisting}[label={lst:Policy2JSQL},language=JavaScript,caption=Policy 2 in JS-QL,mathescape=true]  % float=t?

G.skipZeroOrMore()
.lBrace()
  .assign({leftName:'?name'})
  .or()
  .variableDeclaration({leftName:'?name'})
  .or()
  .functionDeclaration({name:'?name'})
.rBrace()
.skipZeroOrMore()
.state({lookup:{
      '?name': '?nameAddr',
      '_global.?name' : '?nameAddr'
    }})
\end{lstlisting}

\subsection{Script inclusions}
\label{subsec:ScriptInclusion}

A well known exploit in JavaScript environments is \textit{heap spraying}\cite{HeapSpraying}. This is an attacking technique that can eventually even compromise a user's system. In short, it arranges the layout of the heap by allocating a vast amount of carefully-chosen strings, installing a certain sequence of bytes at a predetermined location in the memory of a target. When this is achieved, the exploit is triggered. This trigger depends on the user's operating system and browser. Such an agressive attack can be instantiated on the victim's computer by simply including a malicious script. This could be a reason to write a policy which detects all script inclusions. Regular script inclusions through \texttt{<script></script>} tags can be detected by hand. Javascript however also allows programmers to write arbitrary HTML code by using the \texttt{document.write} and \texttt{document.writeln} functions. Listing \ref{lst:ScriptInclusion} gives an example of malicious script inclusions.

\begin{lstlisting}[label={lst:ScriptInclusion},language=JavaScript,caption=Script inclusion example,mathescape=true]  % float=t?

var evilScript;
var scripts = ["<script>bad1</script>","<script>bad2</script>"];

for(var i = 0; i < scripts.length; i++){
  evilScript = scripts[i];
  document.write(evilScript); //violation
}

var o = {};
o.f = document.writeln;
o.f("<script>bad3</script>"); //Violation
\end{lstlisting}

This policy can be written with only a few lines of datalog in GateKeeper. What needs to be detected are the calls to \texttt{document.write/document.writeln}, even when they are aliased. This is important to note because scripts used for attacks are often obfuscated. The policy in listing \ref{lst:Policy3GK} does just that. \texttt{DocumentWrite(i)} first looks for the address \texttt{d} on the heap which points to the global \texttt{document} object. Next, the location of the property \texttt{write/writeln} of that object is reified in variable \texttt{m}. This is also an address on the heap. The last step is to find all call sites \texttt{i} that point to that same address on the heap. 

\begin{lstlisting}[label={lst:Policy3GK},language=Prolog,caption=Policy 3 in GateKeeper,mathescape=true]  % float=t?

DocumentWrite(i) :- GlobalSym("document",d),
                    HeapPtsTo(d,"write",m),
                    Calls(i,m).

DocumentWrite(i) :- GlobalSym("document",d),
                    HeapPtsTo(d,"writeln",m),
                    Calls(i,m).
\end{lstlisting}

JS-QL also proves to be suitable to express such a policy in listing \ref{lst:Policy3JSQL}. The approach we take first skips zero or more states in the JIPDA graph. We specify that we then want to find a function call with the name of the function bound to metavariable \texttt{?name}. In order to know to which address the called function points in the store, we look it up and bind the address to \texttt{?addr} in the lookup-clause of the \texttt{fCall} predicate. Finally we also match the address of \texttt{document.write/document.writeln} to the same \texttt{?addr} metavariable, filtering out all function calls that do not point to this address.

The analysis that we use is context-sensitive and Javascript is lexically scoped. This implies that we need to explicitly specify that we are looking for the address of the \textit{global} \texttt{document.write/document.writeln} object. If we didn't do this and the user has defined an object with the name "document" and a property "write" or "writeln" inside the scope of the current state in the graph, we would get the address of that object instead of the global object. That is why JS-QL provides a \texttt{\_global} keyword which indicates that we need to search for the address in the global namespace. 

\begin{lstlisting}[label={lst:Policy3JSQL},language=JavaScript,caption=Policy 3 in JS-QL,mathescape=true]  % float=t?

G.skipZeroOrMore()
.lBrace()
.fCall({
  name: '?name',
  lookup:{
    '?name'   : '?addr',
    '$\_$global.document.write': '?addr',
    }
})
.or()
.fCall({
  name: '?name',
  lookup:{
    '?name'   : '?addr',
    '$\_$global.document.writeln': '?addr',
    }
})
.rBrace()
\end{lstlisting}

%GK is flow insensitive, mijn vb gaat meer vinden

\subsection{Conclusion}
 In this section we expressed 3 policies in the GateKeeper language and JS-QL. As table \ref{tab:GKJSQL} indicates, all policies expressed in GateKeeper were also expressible in JS-QL. Gatekeeper excels in writing concise policies to detect certain individual properties of a program. It is however difficult, if not impossible, to express a policy which finds a sequence of properties in a program. JS-QL does not have this problem. The language is designed to match states along an abstract state graph. While it can also express individual properties of a program such as calls of a certain method, it is also capable of finding complex patterns. Two other features that JS-QL offers and GateKeeper lacks is filtering and defining extra properties. It would be very cumbersome to write a policy in GateKeeper to find all function calls to methods that take more than four arguments (This is a bad code smell according to \cite{MaintainableSoftware}). JS-QL provides the \texttt{properties} and \texttt{filters} constructs to express this.
 Since the analysis used by GateKeeper is flow insensitive, it won't detect some violations of policies. Control flow statements like \texttt{forStatement} aren't considered, so everything that happens inside these statements isn't checked for violations. This means that in code listing \ref{lst:ScriptInclusion}, the function call on line 6 won't be marked as a violation. JS-QL does detect this violation.

 \begin{table}[!htb]
  
  \begin{center}
  
    \begin{tabular}{ | l || l | l | l |}
    \hline
    Language & Policy 1 & Policy 2 & Policy 3 \\ \hline
    Gatekeeper & \cmark & \cmark & \cmark \\ \hline
    JS-QL & \cmark & \cmark & \cmark \\ \hline
    \end{tabular}
    \caption*{Legend: \cmark: Fully expressible}
    \caption{Expressiveness in JS-QL and GateKeeper}\label{tab:GKJSQL}
  \end{center}
\end{table}

 We conclude that our language is more expressive since we are able to express sequences and extra properties/filters for example, increasing the flexibility of policies. GateKeeper on the other hand is less verbose in most situations. This is because we have to express everything we want to detect inside the constructs of JS-QL (like \texttt{state(\{\dots\})}). Data flow analysis for example happens behind the scenes in GateKeeper, whereas JS-QL has to do the checks for aliasing in the language itself. An example can be seen in \ref{subsec:ScriptInclusion}, where we have to explicitly match the address of the called function to the address of \texttt{document.write/writeln}. This matching happens internally in Gatekeeper.


\section{The PidginQL language}
\label{sec:ValidationPidginQL}

In this chapter we attempt to express 3 policies originally presented in \cite{PidginQLTechReport}.

\subsection{Only CMS administrators can send a message to all CMS users}
%Context uitleg
Imagine a situation where not only administrators can send broadcast messages. A regular user with bad intentions could easily take advantage of this situation to cause harm to the system. A CMS application for instance with a decent size of users could be exploited by sending a message to all users, asking them to reply with their password. When the attacker provides a reason to the victims convincing them to send their password, he could possibly compromise the contents of the victim's account. An example of such a reason could be that the 'administrator' needs to have the password of a user account in order to update the software of that user to the latest version. This behaviour is undesirable, thus we need a policy which prevents regular users from sending such messages.

The policy described in \cite{PidginQLTechReport} that addresses this issue can be found in listing \ref{lst:Policy4PidginQL}. First, all nodes that are entries of the \texttt{addNotice} method are searched for and stored in a variable. \texttt{addNotice} is the method that sends messages to all users, and has the same behaviour as the broadcast method in the explanation above. Next, all points in the PDG are found that match a return node of the \texttt{isCMSAdmin} method with a return value which is truthy. In order to know if there exists some path in the graph where \texttt{addNotice} is called when the return value of \texttt{isCMSAdmin} is false, all paths between the nodes in \texttt{addNotice} and \texttt{isAdmin} are removed from the graph for all paths where \texttt{isAdmin} is true. Finally, the intersection of the nodes in this 'unsanitized' graph and the nodes in the \texttt{sensitiveOps} argument is taken. When this intersection is not empty, we can assume that there is a violation of the policy in the remainder of the graph. This last part is exactly what the \texttt{accessControlled} method does.

%AccessControlled = let accessControlled(G, checks, sensitiveOps) = G.removeControlDeps(checks) ∩ sensitiveOps is empty
\begin{lstlisting}[label={lst:Policy4PidginQL},language=JavaScript,caption=Policy 4 in PidginQL,mathescape=true]  % float=t?

let accessControlled(G, checks, sensitiveOps) = 
    G.removeControlDeps(checks) $\cap$ sensitiveOps is empty

let addNotice = pgm.entriesOf("addNotice") in
let isAdmin   = pgm.returnsOf("isCMSAdmin") in 
let isAdminTrue = pgm.findPCNodes(isAdmin,TRUE) in
                pgm.accessControlled(isAdminTrue, addNotice)
\end{lstlisting}

When attempting to write a similar query in JS-QL, we need to define the problem in terms of control flow: "There must be no path between the returns of \texttt{isCMSAdmin} when the return value is false, and a call of the \texttt{addNotice} method." We must note that with abstract interpretation, it is not trivial to specify whether a value is truthy or falsy. When looking at a conditional (like an \texttt{IfStatement}), we can determine whether the true of false branch has been taken by comparing the first node of the branches with the alternate/consequent of the conditional. This can be seen on lines 2 and 6 of listing \ref{lst:Policy4JSQL}, where the \texttt{?alt} variable of the \texttt{IfStatement} gets matched with one of the successive states, ensuring that that state is the beginning of the false branch. We bind the context of the branch state to \textit{?kont} and the stack to \textit{?lkont}. The next time we find a state with the same context and stack, we know that the end of the branch has been reached. Lines 8-9 indicate that we only wish to find the calls to \texttt{addNotice} before the end of the branch.

While this policy finds all cases where \texttt{isCMSAdmin} is false, it will not detect calls to \texttt{addNotice} outside this test. We can solve this by finding all calls to \texttt{addNotice}, but this leads to false positives. It would be ideal to have a means to express the \textit{XOR} relation between results of the JS-QL policies. If we had this kind of mechanism at hands, we could search for all calls to \texttt{addNotice} and the calls to \texttt{addNotice} that happen in the true branch of \texttt{isCMSAdmin} and remove all states that occur in both results. The result of this removal would then contain only the violations of the policy.

\begin{lstlisting}[label={lst:Policy4JSQL},language=JavaScript,caption=Policy 4 in JS-QL]  % float=t?

G.skipZeroOrMore()
.ifStatement({alt:'?alt'})
.skipZeroOrMore()
.fCall({name:'isCMSAdmin'})
.skipZeroOrMore()
.state({node:'?alt', kont:'?k',lkont:'?lk'})
.not().endIf({kont: '?k', lkont:'?lk'}).star()
.fCall({name:'addNotice'})
\end{lstlisting}


\subsection{Public outputs do not depend on a user's password, unless it has been cryptographically hashed}

Password information is something most people want to keep to themselves. It is therefor not desirable that sensitive information about this password is leaked in any way to public outputs. This leak of information doesn't have to be explicit however. Imagine a situation where a malicious piece of code checks if the length of the password is larger than 5. If the condition is true the output will display 1, otherwise the output is 0. This also reveals information about the password, and thus should be treated as a violation. The name for this kind of information flow is \textit{implicit flow}.

\begin{lstlisting}[label={lst:PWDepends},language=JavaScript,caption=The output depends on the password example,mathescape=true]  % float=t?

var password = getPassword();
//computeHash(password);
var message;
if(password.length() > 5){
  message = 1;
  print(message);
}
else{
  message = 0;
  print(message);
}
\end{lstlisting}

Since the PidginQL paper represents the program as a program dependence graph, the 'depends' relation is easily checked. In the graph there must be no path between the retrieval of the password and an output, unless \texttt{computeHash} was called. \textit{Declassification} happens when calling this method, which means that from then on the password is sanitized and ready to flow to an output. The policy in listing \ref{lst:Policy5PidginQL} displays how this can be expressed in the PidginQL language.

\begin{lstlisting}[label={lst:Policy5PidginQL},language=JavaScript,caption=Policy 5 in PidginQL,mathescape=true]  % float=t?

let passwords = pgm.returnsOf("getPassword") in 
let outputs   = pgm.formalsOf("writeToStorage") $\cup$
                pgm.formalsOf("print") in
let hashFormals = pgm.formalsOf("computeHash") in
pgm.declassifies(hashFormals, passwords, outputs)
\end{lstlisting}

The scenario for which we write a policy in JS-QL is as follows: An output depends on the password when the password is used in a conditional expression. In one or more of the branches of this conditional expression an output function is then called. The example code on which we test our policy is listed in listing \ref{lst:PWDepends}. We look for a state in the graph where the password is returned, and we store the address in \texttt{?addr}. The program then continues for some states in which the \texttt{computeHash} method is \textit{not} called with the password as an argument (lines 3-16). We then match a state representing a conditional node, in this case an \texttt{IfStatement} for which we bind the true branch to \texttt{?cons} and the false branch to \texttt{?alt}. Note that in the JIPDA abstract state graph, all evaluation steps are visible in the graph. This gives us an opportunity to check if somewhere in the condition of the conditional the password is used, before the actual branching happens. The \texttt{variableUse} predicate on line 19 performs this check. It matches any state in which a variable is used. The declarative nature of the predicates allows us to pass the address of the variable as a metavariable, so that we can specify that we only want to match the uses of the variable whose address is alread captured in \texttt{?addr}. When this results in a match, we know that the variable has been used in the evaluation of the condition of the conditional. Finally, we proceed by checking if an output function (\texttt{print} in this case) is called \textit{inside} one of the branches of the conditional. We do this by matching the nodes of states to the already bound \texttt{?cons} and \texttt{?alt}. A match indicates that that state is the beginning of the true branch or false branch respectively. For these branches, we capture the context and current stack in two additional metavariables \texttt{?k} and \texttt{?lk}. These will be needed on line 26 to indicate that we want to find the call to \texttt{print} \textit{before} the branch ends. This policy, found in listing \ref{lst:Policy5JSQL}, can be made more general by writing a predicate which captures all conditionals instead of just \texttt{IfStatement}s.

\begin{lstlisting}[label={lst:Policy5JSQL},language=JavaScript,caption=Policy 5 in JSQL,mathescape=true]  % float=t?

G.skipZeroOrMore()
.procedureExit({functionName:'getPassword', returnAddr : '?addr'})
.not()
  .state({
    node:{  
      expression: {
          callee: { name:'computeHash' },
          arguments: '?args'
      }
    },
    properties: {
      '?arg' : prop('memberOf', '?args'),
      '?firstName': '?arg.name'
    },
    lookup:{ '?firstName' : '?addr' }
  }).star()
.ifStatement({cons:'?cons', alt:'?alt'})
.skipZeroOrMore()
.variableUse({addr:'?addr'})
.skipZeroOrMore()
.lBrace()
  .state({node:{this:'?cons'}, kont:'?k', lkont:'?lk'})
  .or()
  .state({node:{this:'?alt'}, kont:'?k', lkont:'?lk'})
.rBrace()
.not().state({kont:'?k', lkont:'?lk'}).star()
.fCall({name: 'print'})
\end{lstlisting}
 
%We do have to admit that it is nearly impossible to express a policy which checks all dependencies, since our query languages works on an underlying abstract state graph instead of a program dependence graph. We illustrate this in the following scenario: Instead of using \texttt{password.length > 5} in the conditional, the length is stored in another variable \texttt{length}. We won't detect violations when the following expression is used as a condition: \texttt{length > 5}, since we can't mark the length 
%TODO COEN VRAGEN OF IK MET TAINT MOET PROBEREN


\subsection{A database is opened only after the master password
is checked or when creating a new database}

A database can contain a lot of sensitive information, so it is important that only authorized people can access this information. It might thus be a good idea to restrict access to the database entirely, unless upon creation or when the correct credentials can be presented. 

The PidginQL query in listing \ref{lst:Policy6PidginQL} describes the query pattern in pseudocode, since they had no clean way of expressing this policy. All nodes corresponding to checks of the master password are stored in the \texttt{check} variable. Lines 2 and 3 remove these nodes from the graph when the condition is true (i.e. when the master password is correct). Lastly, the nodes where the creation of a new database occurs are also deleted from the graph, resulting in a graph which consists of only nodes that represent the opening of the database. If the graph is empty, then there are no violations found.

\begin{lstlisting}[label={lst:Policy6PidginQL},language=JavaScript,caption=Policy 6 in PidginQL,mathescape=true]  % float=t?

let check = (all checks of the password)
let checkTrue = pdg.findPCNodes(check, TRUE) in
let notChecked = pdg.removeControlDeps(checkTrue) in
let newDB = (method to create database)
let openDB = (method called to open the database)
notChecked.removeNodes(newDB) and openDB is empty
\end{lstlisting}

Although PidginQL doesn't offer a concrete implementation of the policy, JS-QL does. We created 2 policies that provide full coverage for the problem that is presented in this section, listed in listing \ref{lst:Policy6JSQL}. The problem can be worded otherwise: We want to find all calls to \texttt{openDatabase} that are not inside the true branch of a conditional that checks if the master password is correct. When described like this, the policy gets much more intuitive to express in JS-QL. The policy can be split up in two parts: The first part will skip to an \texttt{IfStatement} of which we bind the true branch to \texttt{?cons}, as in the previous example. We then again check if the condition of that statement uses the \texttt{isMasterPassword} to verify the correctness of the password. We want to look into all states for which this condition doesn't hold, which is described on line 7. In this case all calls to \texttt{openDatabase} are prohibited, except inside the \texttt{newDatabase} function. This policy catches all violations \textit{after} the first matching \texttt{IfStatement}. That is why there is the need for a second part in the policy. The detection of all calls to the \texttt{openDataBase} function completes this policy, but adds as a side effect that it will add false positives. These false positives will be the calls to \texttt{openDatabase} that occur when the master password is correct. This confirms the need for the \textit{XOR} relation, as described in the previous section. 

\begin{lstlisting}[label={lst:Policy6JSQL},language=JavaScript,caption=Policy 6 in JS-QL,mathescape=true]  % float=t?

G.skipZeroOrMore()
.lBrace()
  .lBrace()
    .ifStatement({cons:'?cons'})
    .skipZeroOrMore()
    .fCall({name:'isMasterPassword'})
    .not().state({node:'?cons'}).star()
    .beginApply({name:'?name', lkont:'?lk', kont:'?k',
                 filters:[
                  cond('!==', '?name', 'newDatabase')
                 ]})
    .not().endApply({lkont:'?lk', kont:'?k'}).star()
    .fCall({name:'openDatabase'})
  .rBrace()
  .or()
  .fCall({name:'openDatabase'})
.rBrace()
\end{lstlisting}


\subsection{Conclusion}
In this section we expressed 3 policies in the PidginQL language and JS-QL. Table \ref{tab:PidginQLJSQL} indicates that not all three policies were easily expressible. We are able to express all 3 policies in JS-QL, but 2 of them will have results containing false positives. These two policies each consisted of two separate queries. If we wish to attain a resultset only containing violations and no false positives, we could take the exclusive disjunction of the resultsets of these separate queries. The PidginQL language is best at expressing policies that deal with the dependencies between nodes in their program dependence graph. This type of graph is very powerful to check the control and data flow between two parts of code\cite{PDG}, but it is more difficult to use it to detect more general properties about a program. For JS-QL, it is the other way around. Our technique allows us to detect a wide range of general and complex properties about a program, but sometimes has troubles detect dependencies between states with only one policy. PidginQl may be powerful in finding dependencies as described above, it does however not return much meaningful information about the found violations. Where JS-QL returns all violating nodes marked in a GUI, PidginQl just indicates whether there are violations or not. It doesn't specify which nodes are violating the policy.

 \begin{table}[!htb]
  
  \begin{center}
  
    \begin{tabular}{ | l || l | l | l |}
    \hline
    Language & Policy 4 & Policy 5 & Policy 6 \\ \hline
    PidginQL & \cmark & \cmark & \cmark \\ \hline
    JS-QL & \omark & \cmark & \omark \\ \hline
    \end{tabular}
    \caption*{Legend: \cmark: Fully expressible, \omark: Expressible with false positives}
    \caption{Expressiveness in JS-QL and GateKeeper}\label{tab:PidginQLJSQL}
  \end{center}
\end{table}

Another restriction in PidginQL is that there is no way to reason about the internals of a state in the graph. Our language allows the programmer to query information in the graph on the level of each state. We can dig inside a state at any time and specify the information we wish to obtain in some user-declared metavariables. This is not possible in PidginQL. This expressiveness and flexibility brings along that JS-QL queries and policies will often be more verbose.

We can conclude that both languages are equally expressive in their own way. While JS-QL can be used for many different domains, PidginQL is especially strong in it's own domain, namely in querying for dependencies between nodes.

\section{The ConScript language}
\label{sec:ValidationConscript}

In this chapter we attempt to express 3 policies originally presented in \cite{ConScript}.

\subsection{No string arguments to setInterval, setTimeout}

\texttt{setInterval} and \texttt{setTimeout} take a callback function as a first argument. This function is fired after a certain interal or timeout. Surprisingly, a string argument can also be passed as the first argument. This is good news for possible attackers, because the string gets evaluated as if it were a regular, good-behaving piece of JavaScript code. Malicious code can then be passed as a string argument to \texttt{setInterval/setTimeout}, which can lead to a security threat.


\begin{lstlisting}[label={lst:JSSetTimeout},language=JavaScript,caption=No string arguments to setTimeout,mathescape=true]  % float=t?

var f = function(){}
var i = 1;
var s = "stringgy"
var o = {};
setTimeout(i, interval);
setTimeout(s, interval);  //Violation
setTimeout(o, interval);
setTimeout(f, interval);
\end{lstlisting}

ConScript is an aspect-oriented advice language that deals with security violations just like this. The aspects are written in JavaScript, which enables the programmer to make full use of the language. They also provide a typesystem which assures that the policies are written correctly, as can be seen in listing \ref{lst:Policy7Conscript} on line 1. Lines 10-11 depict the actual registration of the advice on the \texttt{setInterval} and \texttt{setTimeout} functions. When called, the \texttt{onlyFnc} function will be triggered instead, which checks if the type of the argument is indeed of type "function". \texttt{curse()} has to be called within the advice function, disabling the advice in order to prevent an infinite loop. We consider this as a small hack, since it has no semantic additional value for the policy itself.

\begin{lstlisting}[label={lst:Policy7Conscript},language=JavaScript,caption=Policy 7 in ConScript,mathescape=true]  % float=t?

let onlyFnc : K x U x U -> K =
function (setWhen : K, fn : U, time : U) {
    if ((typeof fn) != "function") {
        curse();
        throw "The time API requires functions as inputs.";
    } else {
        return setWhen(fn, time);
    }
};
around(setInterval, onlyFnc); 
around(setTimeout, onlyFnc);
\end{lstlisting}

%Policy in JS-QL
Since we can't reason about concrete values in abstract interpretation, writing a policy that only allows strings might seem a little more tricky. This is not the case because the lattice we use gives us information about the type of the value of variables. A string for example is indicated by the lattice value \texttt{\{Str\}}. We can then define a \texttt{isString} helper function which checks whether a variable is of type String or not. The JS-QL policy in listing \ref{lst:Policy7JSQL} uses this function to determine whether the looked up value of the \texttt{?name} variable is of type String or not. The policy looks for a call of the \texttt{setTimeout} function and binds its arguments to \texttt{?args}. \texttt{memberOf} is a powerful construct which creates a new substitution set for each of the elements in the list that it takes as an argument.
This allows us to inspect and check each individual argument \texttt{?arg} of the \texttt{setTimeout} function. We take the name of the argument and look up its value in the lookup clause. What remains is to filter out the string arguments, as already discussed above. This policy will only detect the actual violation on line x in listing \ref{lst:JSSetTimeout}.

\begin{lstlisting}[label={lst:Policy7JSQL},language=JavaScript,caption=Policy 7 in JS-QL,mathescape=true]  % float=t?

G.skipZeroOrMore()
.fCall({
  name:'setTimeout',
  arguments:'?args',
  properties:{
    '?arg' : prop('memberOf', '?args'),
    '?name': '?arg.name',
  },
  lookup:{'?name': '?lookedUp'},
  filters:[
    cond('isString', '?lookedUp')
  ]
})
\end{lstlisting}

%Bespreken

\subsection{HTTP-cookies only}
\label{subsec:HTTPOnly}

Servers often store state information on the client in the form of cookies. They do this to avoid the cost of maintaining session state between calls to the server. Cookies may therefor contain sensitive information that may only be accessed by the server, so it might be a good idea to prohibit reads and writes to the client's cookies. These are stored in the global \texttt{document.cookie} object. Listing \ref{lst:HTTPCookiesOnly} gives an example of possible violations.

\begin{lstlisting}[label={lst:HTTPCookiesOnly},language=JavaScript,caption=HTTP-cookies only example,mathescape=true]  % float=t?

var doc, cookie1, cookie2, cookie3, badFunc;
badFunc = function(){
  var bad;
  bad = document.cookie;        //Violation (read)
  return bad;
}

cookie1 = document.cookie;      //Violation (read)
doc = document;
cookie2 = doc.cookie;           //Violation (read)
cookie3 = badFunc();            //Violation (read)
document.cookie = {value:"bad"} //Violation (write)
\end{lstlisting}

Registering advices around functions is easy. In conscript, the above policy can be enforced with only a few lines of code. Listing \ref{Policy8Conscript} wraps reads and writes of the "cookie" field of \texttt{document} in the \texttt{httpOnly} advice. An error is thrown when a violation against this policy is encountered.

\begin{lstlisting}[label={lst:Policy8Conscript},language=JavaScript,caption=Policy 8 in ConScript,mathescape=true]  % float=t?

let httpOnly:K->K=function(_:K){ 
    curse(); 
    throw "HTTP-only cookies"; 
};
around(getField(document, "cookie"), httpOnly); 
around(setField(document, "cookie"), httpOnly);
\end{lstlisting}

Writing an equivalent JS-QL policy proves to be a little more verbose. The reason for this is that we only work with our own embedded DSL to query the information in the JIPDA graph. While the \texttt{getField} and \texttt{setField} in \ref{lst:Policy8Conscript} handle the lookup of the address of \texttt{document.cookie}, we have to manually specify that we want to store the address in metavariable \texttt{?cookieAddr} and try to match it with the address of the \texttt{?name} metavariable, which we assign to the same metavariable \texttt{?cookieAddr} to filter out variables with a different address. The JS-QL policy in \ref{lst:Policy8JSQL} specifies that it will only detect writes (the first \texttt{assign} predicate) and reads (the \texttt{procedureExit} and second \texttt{assign} predicate) of the \texttt{?name} variable which points to the address of the global \texttt{document.cookie} object. It is easy to see what the \texttt{assign} predicate does: In this case, it matches the left or right name of the assignment and looks it up. The \texttt{procedureExit} is an extra predicate which marks all returns of functions that return a value that again points to the address of the global \texttt{document.cookie} address.


\begin{lstlisting}[label={lst:Policy8JSQL},language=JavaScript,caption=Policy 8 in JS-QL,mathescape=true]  % float=t?

G.skipZeroOrMore()
.lBrace()
  .assign({leftName:'?name',
           lookup:
           {
               '_global.document.cookie' : '?cookieAddr',
               '?name'                   : '?cookieAddr' 
           }
          })
  .or()
  .assign({rightName:'?name',
           lookup:
           {
               '_global.document.cookie' : '?cookieAddr',
               '?name'                   : '?cookieAddr' 
           }
          })
  .or()
  .procedureExit({returnName:'?name',
                  lookup:
                  {
                      '_global.document.cookie' : '?cookieAddr',
                      '?name'                   : '?cookieAddr'  
                  }
                })
.rBrace()
\end{lstlisting}


%Wat als in functie, geeft dan conscript geen false positives?
%We kunnen dit uiteraard inkorten naar een httpOnly predikaat, maar dan konden we niet laten zien hoe je het doet in JS-QL

\subsection{Prevent resource abuse}

Malicious scripts can prevent parts of a program to be accessible by users. Think of a website you want to access, but every time you scroll or click a mouse button, a popup appears. This is a form of resource abuse, namely the abuse of modal dialogs. This can be prevented by prohibiting calls to functions that create these resources. The ConScript policy is similar to the policy discussed in section \ref{subsec:HTTPOnly}. Calls to \texttt{prompt} and \texttt{alert} are wrapped in an advice which throws an error. Listing \ref{lst:Policy9Conscript} shows the source code of the policy.

\begin{lstlisting}[label={lst:Policy9Conscript},language=JavaScript,caption=Policy 9 in ConScript,mathescape=true]  % float=t?

let err : K -> K = function () { 
    curse(); 
    throw 'err'; 
}); 
around(prompt, err); 
around(alert, err);
\end{lstlisting}

Wrapping an advice around a function to detect calls to that function is a way to prohibit the invocation of that function. To find function invocations in JS-QL, one just has to write a policy consisting of a \texttt{fCall} predicate. This predicate has to be configured to return all relevant information we need about the function call. In listing \ref{lst:Policy9JSQL} we can see that a function call (AST) node contains fields for its \texttt{procedure} and its \texttt{arguments}. We bind these to \texttt{?proc} and \texttt{?args} respectively. We then further define an extra metavariable \texttt{?name} in the \texttt{properties} clause of the predicate, which maps to the name of the earlier defined \texttt{?proc}. Once we have the information about the function that is invoked, we can look up its address and compare it to the address of the global \texttt{alert} (or \texttt{prompt}) function. When these are equal, the substitutions for the detected function call will be added to the results.

\begin{lstlisting}[label={lst:Policy9JSQL},language=JavaScript,caption=Policy 9 in JS-QL,mathescape=true]  % float=t?

G.skipZeroOrMore()
.fCall({
  procedure:'?proc',
  arguments:'?args',
  properties:{
    '?name' : '?proc.name'
  },
  lookup:{'?name': '?alertAddress',
          '_global.alert': '?alertAddress'}
})
\end{lstlisting}











\subsection{Conclusion}
TODO
%hack van cures() maakt meer verbose
%Zij kunnen enkel function calls policies op toepassen
%Uitdrukken van sequences van nodes enkel via declaren van variabelen (No redirection after reading cookie)
%Kunnen ook filteren en properties uitdrukken (door JS te gebruiken)
%Zij kunnen wel andere acties ondernemen als violation, wij enkel detecten
%Wij kunnen veel meer detecten omdat zij niet op graph werken, zij kunnen enkel aspects op functies wrappen

In this section we expressed 3 policies in the ConScript language and JS-QL.

 %In this section we expressed 3 policies in the GateKeeper language and JS-QL. As table \ref{tab:GKJSQL} indicates, all policies expressed in GateKeeper were also expressible in JS-QL. Gatekeeper excels in writing concise policies to detect certain individual properties of a program. It is however difficult, if not impossible, to express a policy which finds a sequence of properties in a program. JS-QL does not have this problem. The language is designed to match states along an abstract state graph. While it can also express individual properties of a program such as calls of a certain method, it is also capable of finding complex patterns. Two other features that JS-QL offers and GateKeeper lacks is filtering and defining extra properties. It would be very cumbersome to write a policy in GateKeeper to find all function calls to methods that take more than four arguments (This is a bad code smell according to \cite{MaintainableSoftware}). JS-QL provides the \texttt{properties} and \texttt{filters} constructs to express this.
 %Since the analysis used by GateKeeper is flow insensitive, it won't detect some violations of policies. Control flow statements like \texttt{forStatement} aren't considered, so everything that happens inside these statements isn't checked for violations. This means that in code listing \ref{lst:ScriptInclusion}, the function call on line 6 won't be marked as a violation. JS-QL does detect this violation.

 \begin{table}[!htb]
  
  \begin{center}
  
    \begin{tabular}{ | l || l | l | l |}
    \hline
    Language & Policy 7 & Policy 8 & Policy 9 \\ \hline
    Gatekeeper & \cmark & \cmark & \cmark \\ \hline
    JS-QL & \cmark & \cmark & \cmark \\ \hline
    \end{tabular}
    \caption*{Legend: \cmark: Fully expressible}
    \caption{Expressiveness in JS-QL and ConScript}\label{tab:GKJSQL}
  \end{center}
\end{table}

 %We conclude that our language is more expressive since we are able to express sequences and extra properties/filters for example, increasing the flexibility of policies. GateKeeper on the other hand is less verbose in most situations. This is because we have to express everything we want to detect inside the constructs of JS-QL (like \texttt{state(\{\dots\})}). Data flow analysis for example happens behind the scenes in GateKeeper, whereas JS-QL has to do the checks for aliasing in the language itself. An example can be seen in \ref{subsec:ScriptInclusion}, where we have to explicitly match the address of the called function to the address of \texttt{document.write/writeln}. This matching happens internally in Gatekeeper.











\section{Evaluation}
\label{sec:ValidationEvaluation}
TODO
%Nadeel bvb eerste policy van PidginQL: we kunnen niet naar concrete waarden kijken , bvb user.isAdmin zal {bool} zijn, maar weet niet of dit true of false is
%WIJ KUNNEN NOT UITDRUKKEN ALSOOK RECURSIE
%Wij niet enkel node info maar state info
%tradeoff tussen expressiveness en flexibility & verbosity en conciseness


  \begin{table}\begin{center}
    \begin{tabular}{ | l || l | l | l |}
    \hline
    Language & Prop1 & Prop2 & Prop3 \\ \hline
    JS-QL &  &  & \\ \hline
    GateKeeper &  &  & \\ \hline
    PidginQL &  &  & \\ \hline
    Conscript &  &  & \\ \hline
    \end{tabular}
    \caption*{Test}\end{center}
  \end{table}

