In this chapter we present the JS-QL framework. The framework offers the possibility for developers to write application-specific queries to check for certain program properties. More specific, it tries to offer a solution to developers who want to test their applications for vulnerabilities by writing and enforcing security policies for them. The framework consists of three main parts: 
\begin{enumerate}
\item \textit{The JS-QL query language}: Short for \textbf{J}ava\textbf{S}cript \textbf{Q}uery \textbf{L}anguage. This is the domain-specific language in which users can express all kinds of security policies. An overview of the language is given in section \ref{sec:syntax}.
\item \textit{The matching engine}: This is the core of the framework. It matches the user-defined query against states of the JIPDA abstract state graph, capturing and unifying all the relevant information. This engine can be configured to behave differently for certain queries, as will be discussed in section \ref{sec:TypesOfQueries}.
\item \textit{The graphical user interface}: The user interface provides the infrastructure for the developer to interact with the framework. It contains a section where users can specify the input program and security policy, a graphical component representing the abstract state graph corresponding to the input program and a visual and textual representation of the query results. The textual representation allows developers to inspect the captured variables, a handy feature when these variables are compound data structures. The user interface is displayed in figure \ref{fig:UI}.
\end{enumerate}

The abstract state graph obtained from the JIPDA analysis is a perfect starting point to inspect a program for certain characteristics and security vulnerabilities. In chapter \ref{ch:Overview} we motivated our choise to design an internal DSL to query for specific (sequences of) states in this graph, with the aim to discover program patterns that might lead to violations of user-defined security policies. The language constructs are built to make it easy for the user to specify which kind of pattern he wishes to detect. The rest of this section presents all facets of the JS-QL language: Section \ref{sec:Syntax} discusses all constructs of the language and gives an in-depth explanation on how to use them in a correct way. As different security policies require different traversals of the state graph, more than one type of query is needed. We discuss the difference between several query types in section \ref{sec:TypesOfQueries}. In order to have an effective query language, we must allow the user to create compound queries out of the available language constructs. Section \ref{sec:DefiningPolicies} shows how this can be done within the framework.

\section{The JS-QL query language}
\label{sec:Syntax}
 In this section we will discuss the available constructs and syntax of the JS-QL language. The examples in this section will be simplistic and will demonstrate how each construct works. They will therefore not always represent an actual security policy, but will rather serve as a guideline for using these constructs. We chose to use \textit{path expressions} to express queries in JS-QL, and more precisely \textit{regular path expressions}. This adds the flexibility of regular expressions to the language, as the most relevant features of regular expressions are incorporated in JS-QL.

%Entry point
\subsection{The entry point}
As our language is an internal DSL, meaning that it is embedded in a host language, the host language has to provide an entry point from where we can start using the JS-QL language. We chose to map this point to the \texttt{G} object, which is short for \textbf{G}raph. This implies that all query patterns in JS-QL will start from this object. A simple example is seen in \ref{lst:entryPoint}, where the first state of the graph is matched.

\begin{lstlisting}[label={lst:entryPoint},language=JSQL,caption=Matching the first state starting from entry point \texttt{G},mathescape=true]  % float=t?

//Match the first state of the graph
G.state()
\end{lstlisting}

\subsection{State}
the \texttt{state} construct is the single most basic element of the language. It matches any state in the graph, but doesn't provide much information on its own. Nevertheless is it the most important building block of the language, as it can be used to construct higher-level queries and predicates. States can be made more precise and expressive by parametrizing them with \textit{state constraints}, but in order to know what we can query for, we will first give a short overview of what information is available in which states. To get a more detailed explanation on what each piece of information represents, we refer to the section about flow graphs (\ref{subsec:FlowGraphs}). Table \ref{tab:InfoPerState} indicates what information is available in which type of state. The table also shows which keyword is used to represent the information is that is in embodied in the states.

\begin{table}[!h]
\centering
\caption*{
  \centering
  	\begin{tabular}{| l | c |}
  	\hline
  	\multicolumn{2}{ |c| }{Legend} \\
  	\hline
  	Evaluation state & $E$  \\
  	Continuation state & $K$  \\
  	Return state & $R_t$  \\
  	Result state & $R_s$  \\
  	All states & $A$  \\
  	\hline
  	\end{tabular}
  	%$E$ = EvalState, $K$ = KontState, $R_t$ = ReturnState, $R_s$ = ResultState, $A$ = All states
  }
  \begin{tabular}{| l | l | c |}
  \hline
  State property & Available in states & Keyword\\
  \hline
  Node & $E$ & node\\
  Meta continuation & $A$ & kont\\
  Local continuation & $A$ & lkont\\
  Binding environment & $E$ & benv\\
  Store & $A$ & store\\
  Value & $K$ $R_t$ $R_s$ & value\\ \hline \hline
  Identifier & $A$ & \_id\\
  Successors & $A$ & \_successors \\
  \hline

  \end{tabular}
  
  \caption{Information in the states of the abstract state graph}
  \label{tab:InfoPerState}
\end{table}

As readability is key in a query language, JS-QL provides four extra constructs that are semantically almost equivalent to the regular \texttt{state} construct. \texttt{evalState}, \texttt{kontState}, \texttt{returnState} and \texttt{resultState} are included in the language, with the purpose of enhancing readability, but also to match only those specific kinds of states.
Note that the framework also supports the usage of the identifier and successors of a state, but it is very uncommon to use them, as they are semantically irrelevant to queries. The identifier of a state would only be relevant when a query is matched in that exact state. When this is the case, the state gets marked in the visual graph representation and all query information is then contained in that state. To retrieve the information, one simply has to click the state to inspect all variable values. Successors also contain few additional information, as all direct successors of a state are already made explicit in the state graph. A use case for the use of the successors keyword could be to find all states after which some branching occurs. This could then be specified as a JS-QL query which captures the successors array in a variable \texttt{?succArr}, and then filters the results to only contain the states with the length of \texttt{?succArr} strictly greater than 1.


To understand how we can parametrize states, we first have to know how to define variables in JS-QL. Variables in JS-QL are strings, starting with a \texttt{?}. The fact that we use strings comes from the embedded nature of our language: If we were to specify variables as literals, the host language would complaint that it doesn't recognize the literal. Listing \ref{lst:stringVariables} illustrates this.

\begin{lstlisting}[label={lst:stringVariables},language=JSQL,caption=Defining variables in JS-QL,mathescape=true]  % float=t?

//Capture the 'type' property of the node in variable '?nType'
G.state({ node : { type: '?nType' }})
//Exception: ?nType is not recognized by the host language
G.state({ node : { type: ?nType }}) 
\end{lstlisting}

As the example might already indicate, JS-QL deconstructs state properties as nested key-value pairs. In this way, each part of information can be captured in a variable. The key indicates the property the user wishes to match whereas the value can be one of three things:
\begin{enumerate}
\item A \textit{variable}. When placing a variable as the value in a key-value pair in JS-QL, that variable gets bound to the key's corresponding value in the JIPDA state. The '?nType' variable in the example above gets bound to the value of \texttt{type}, which in this case corresponds with the type of the AST \texttt{node} for the currently matched state.
\item A \textit{nested map} which further deconstructs the current property. The example above does this by further deconstructing the \texttt{node} property of a state (which represents the corresponding AST node) in order to reach the \texttt{type} of that node and store it in a variable. It is obvious that this is most used to match specific AST nodes.
\item A \textit{literal}. Literals are mostly used to filter the states to be matched. When applying this to the example above, the '?nType' variable could be replaced by the literal 'ExpressionStatement' for example. Note that the question mark (\texttt{?}) is omitted. The resulting query would then only match a state having the \texttt{type} of its corresponding AST \texttt{node} equal to 'ExpressionStatement'.
\end{enumerate}

%Kort door de bocht?
\noindent States can thus be parametrized by matching the keywords displayed in table \ref{tab:InfoPerState} as keys with values that can be variables, literals or nested maps. It is obvious that queries matching single-state patterns aren't quite qualified as being security policies. JS-QL therefore allows users to specify sequences of states as a query. When checking the state graph against this query, all states in the query pattern need to be matched one after another. When a state in the query pattern is encountered that doesn't match the current state in the state graph, the matching process is aborted for the current path that is investigated in the state graph. Consider the following query:

\begin{lstlisting}[label={lst:Unification},language=JSQL,caption=Unification in JS-QL,mathescape=true]  % float=t?

G.state({ node : { type: '?tpe' }})
 .state({ node : { type: '?tpe' }})
\end{lstlisting}

\noindent We immediately see that the variable \texttt{?tpe} occurs twice in the query. This can be done on purpose to achieve \textit{unification}. Unification simply means that two variables with the same name have to contain the same value. After executiong the first line, the first state in the graph is matched (if it has the \texttt{node} property) and the variable \texttt{?tpe} is bound to the type of the node. The matching engine then proceeds to the next state in both the query and the state graph. If the next state again has the \texttt{node} property with the same type as already bound to \texttt{tpe}, the unification process has succeeded and the whole query will match. If the node type of the next state isn't equal to the value already bound to \texttt{?tpe}, or if that state doesn't have a \texttt{node} property, there is no match. The results of a successfully matched query will be the set of all possible \textit{substitutions}, together with the identifier of the state where the last element of the query matched. Figure \ref{fig:Unification} gives a simplistic visual representation of this process for the query listed in listing \ref{lst:Unification}. For the graph on the left-hand side, the query is fully matched by successfully unifying the the type of the first and second state. In contrast, the graph on the right-hand side will not produce a match as $\{$\texttt{?tpe} $:$ 'ExpressionStatement'$\}$ can't'be unified with $\{$\texttt{?tpe} $:$ 'AssignExpression'$\}$. More complex examples of unification can be found later in this chapter.

\begin{figure}[!h]
    \centering
      \includegraphics[width=1\textwidth]{images/Unification} 
      \caption{Visual representation of the unification process}
    \label{fig:Unification}
\end{figure}

All queries presented until now match the state graph from the beginning of the graph only. This behaviour is often undesirable as a developer usually wants to detect a pattern \textit{somewhere} in his code, not necessarily at the beginning. To resolve this, JS-QL combines techniques from regular expressions with a special built-in construct, the \textit{wildcard}.

%TODO: translate variables starting with ! to ?__TMP__

\subsection{Wildcard}

Wildcards are usually known as 'things of which the value can be anything', and this is no exception in JS-QL. A \texttt{wildcard} serves the sole purpose of matching any state it gets compared with. In other words, an equally correct name for this construct could have been \texttt{skip}, as it skips a state in both the query (the \texttt{wildcard} state itself) and the abstract state graph (the state the wildcard gets matched with). When talking about states in a query pattern, both \texttt{state} as \texttt{wildcard} match this definition. \texttt{wildcard}s act just like regular \texttt{state}s in a query, meaning that they only match \textit{1} state in the state graph. It is very unlikely that a developer knows exactly after how many states a violation would occur, so simply enumerating wildcards followed by the state to be matched would typically be a very tiresome effort. We therefore need to be able to specify that we wish to skip \textit{zero or more} states before matching the following state in the query pattern. This is where the power of regular expressions comes in handy. Just like regular expressions, JS-QL supports the use of both the Kleene star (\texttt{star}) and the Kleene plus (\texttt{plus}) operators. In our language, the \texttt{star} and \texttt{plus} constructs are both placed \textit{after} the state(s) they are applied to. Placing \texttt{star} behind a sequence of states indicates that those states can occur \textit{zero or more} times at the current position in the state graph. The semantics of \texttt{plus} are very similar, except for the fact that the states have to occur at least once in the order they are specified. Just like with regular expressions, pieces of a pattern can be surrounded by braces. Left and right braces in JS-QL are denoted by \texttt{lBrace} and \texttt{rBrace} respectively. The default behavior of both the kleene star and kleene plus operators is to apply them to the state that occurs right before it. If any kleene operator has to be applied to multiple states, these states have to be wrapped in braces in JS-QL. Listing \ref{lst:KleeneOperations} shows the differences. Lines 1 and 2 are semantically equivalent, as the braces on line 2 only contain 1 state, a \texttt{wildcard} in this case. Lines 3 and 4 on the other hand are semantically very different. The query on line 3 matches all but the first states in the state graph, whereas the query on line 4 matches every other state in the graph, starting from the second state. The combinations of \texttt{wildcard().star()} and \texttt{wildcard().plus()} are so commonly used in JS-QL, that a special construct is created for each of them: \texttt{skipZeroOrMore()} and \texttt{skipOneOrMore()} respectively.

\begin{lstlisting}[label={lst:KleeneOperations},language=JSQL,caption=Kleene operations differences,mathescape=true]  % float=t?

G.wildcard().star() // Equal to G.skipZeroOrMore()
G.lBrace().wildcard().rBrace().star()
G.wildcard().state().plus()
G.lBrace().wildcard().state().rBrace().plus()
\end{lstlisting}

\subsection{Disjunction}

Sometimes when writing a query, more than one state on the path is allowed for the query to match. Consider a simple language in which we want to detect all uses of a variable \texttt{v}. Using a variable in this language can only be done by using it in an binary arithmetic expression. To keep the example simple, we disregard all other possible uses of a variable. We also assume in this example that no other variable was assigned the value of \texttt{v}, so that no aliases of \texttt{v} exist in the code. When using a variable in a binary arithmetic expression, the variable can be on either side of the operator. A naive solution to query for all uses of \texttt{v} would be to first launch a query that finds all occurences of \texttt{v} on the left-hand side, followed by a query that detects all occurences on the right-hand side. To alleviate the work of the user, JS-QL offers the disjunction construct \texttt{or}, which allows to specify that 1 state in the state graph can be matched by multiple states in the query pattern. If we then were to match all occurrences of \texttt{v} on the left- and right-hand side of arithmetic expressions, we could write a query as in listing \ref{lst:disjunction}.

\begin{lstlisting}[label={lst:disjunction},language=JSQL,caption=The JS-QL disjunction operator,mathescape=true]  % float=t?

G.skipZeroOrMore()
.lBrace()
  //Left-hand side with name 'v'
  .state({node: { type: 'BinaryExpression',
                  left: {name:'v'}}})      
  .or()
  //Right-hand side with name 'v'
  .state({node: { type:  'BinaryExpression',
                  right: {name:'v'}}})
.rBrace()
\end{lstlisting}

This query first skips zero or more states, starting from the beginning of the graph. It then matches a \texttt{state} (\texttt{evalState} would be equally correct) with a \texttt{node} property of type 'BinaryExpression'. Remember that the node property of evaluation states contains the AST information for the current expression. Because of this, the \texttt{left} and \texttt{right} properties of the BinaryExpression are again nodes that can be further deconstructed. The \texttt{or} construct splits the query in two different query paths. One path will try to match the pattern specified before the construct, whereas the other path searches for matches for the pattern specified after the \texttt{or}. The same rules apply w.r.t. braces as for the \texttt{star} and \texttt{plus} operators. For the first path, we deconstruct the left property of the node and match its name with the literal \texttt{v}. This automatically filters out all states for which this condition doesn't hold. What remains is a match for each state for which the condition holds. The same is done for the second path, with the only difference that the name of the right node now has to be equal to \texttt{v}. As the query doesn't store any variables along the path, the result of the query can only be observed in the visual representation of the abstract state graph. In this graph, all matching nodes will be marked with color, indicating a match.

When examining the example above, we notice that very few relevant information is available as a result of the query. A more detailed result should contain the actual node or even the entire state that was matched, so we could inspect it further. To this extent, an additional implicit property was made available for each deconstructable map in the language. This property represents the entire object by which it is encapsulated. We chose to give this property an appropriate name, indicating that it points to the object currently being inspected, namely \texttt{this}. Listing \texttt{lst:updatedDisjunction} gives an updated version of the relevant code from the previous example. In this version, the \texttt{thisNode} variable will be bound to the node of the matched state.

\begin{lstlisting}[label={lst:updatedDisjunction},language=JSQL,caption=Using the \texttt{this} keyword,mathescape=true]  % float=t?

//...
.state({node: { this: '?thisNode',
                type: 'BinaryExpression',
                left: {name:'v'}}})     
//... 
\end{lstlisting}

\subsection{Specifying additional properties}

Sometimes it can be useful to capture extra information about already matched variables. Doing so in a separate section, exclusively designed for this purpose, has two advantages. First of all, it enhances the readability of queries. Queries with deeply nested maps can quickly become confusing to read and bothersome to modify. Secondly, it opens up for opportunities to make the language even more expressive. JS-QL has a built-in keyword \texttt{properties}, which can be used to obtain more information from already bound variables. 

Expressing properties can be done in two ways, as indicated in listing \ref{lst:propertiesExample}. As the language we are using is an embedded language, we can take advantage of the host language. JavaScript allows the value of key-value pairs to be a function call with arguments. We can we can benefit from this by defining a JavaScript function \texttt{prop}, to which we can pass which kind of information we wish to obtain and from which variable we want to obtain these properties. The first argument of \texttt{prop} is the function that needs to be applied when the matching engine processes the query. The arguments of this function are all other arguments that were passed to \texttt{prop}. Lines 5 and 7 of the example below shows how to properly use the \texttt{prop} function. We have to defer the evaluation of the function passed as a first argument to \texttt{prop} because at compile-time the values of the variables aren't calculated yet (as no matching has happened). This function, in the example below 'memberOf', can be a user-specified function or a built-in function. As for now, JS-QL only has three build-in functions that work on variables, and all three require that variable to be of type \textit{Array}:

\begin{enumerate}
\item \textit{length}: A query could contain \texttt{prop('length', '?arr')}, where \texttt{?arr} is a variable with a value of type \texttt{Array}. The function then returns the length of the array bound to the variable.
\item \textit{at}: This function takes 2 additional arguments: A variable containing an array, and an index \texttt{i}. The resulting value is the \texttt{i}th element of the array.
\item \textit{memberOf}: This function is the most important and also most used one. It takes a variable containing an array \texttt{arr} as an argument and expands the current substitution set, so that for each element in \texttt{arr} a new substitution set is created with that element appended to it. In the example below, the substitution set before the execution of line 5 would look like \\\texttt{[\{?decls : [dec1, dec2]\}]}, \\and would afterwards look like: \\\texttt{[\{?decls : [dec1, dec2], ?dec : dec1 \},\\\phantom{ }\{?decls : [dec1, dec2], ?dec : dec2 \}]}
\end{enumerate}

\noindent Another way to define properties is by simply specifying which attribute of a variable one wishes to capture. Line 6 of the example below shows how the 'name' of the 'left' attribute of \texttt{?dec} is bound to \texttt{?decName}. Declaring a new property variable is done similarly for both ways of defining properties: The key of the map should contain the variable name to be declared, whereas the value should be the property specification. One might notice that this order of key-value pairs is different from all other notations in JS-QL. This is because the host language doesn't allow function calls to be keys in maps, and thus restricts the syntax of our language in that way.

The example below matches all states of the state graph that declare variables. These declarations are captured in \texttt{?decls}. Next, for each declaration, a new substitution set is generated by the 'memberOf' function. Each substitution set now contains a variable \texttt{?dec} bound to an element of the \texttt{?decls} array. Finally, the name of the declaration in each substitution set is captured in \texttt{?decName}.

\begin{lstlisting}[label={lst:propertiesExample},language=JSQL,caption=Specifying additional properties in JS-QL,mathescape=true]  % float=t?

G.skipZeroOrMore()
.state({
      node:{ declarations: '?decls' },
      properties:{
        '?dec'     : prop('memberOf', '?decls'),  
        '?decName' : '?dec.left.name'             
        '?decNameU': prop(function(a){            
                            return a.toUpperCase();
                          }, '?decName')
      
      }})
\end{lstlisting}

It is very important to keep in mind that only the variables that are already bound can be used in properties. This implies that the order of the keywords in a query is important for the semantics of the query. If we were to switch the \texttt{node} and \texttt{properties} keywords of the above query, an error would occur because the \texttt{?decls} variable wouldn't be available to use in the properties section.

\subsection{Filtering states}

Filters in JS-QL work very similar to properties, except that they act as guards who filter out states that don't satisfy certain conditions. A filter can be any function, predefined or specified by the user, that returns a boolean value. When returning true the pattern can be matched further, otherwise the matching process aborts and no match for the current path in the state graph is found. A filter is declared through the \texttt{cond} JavaScript function (similar to \texttt{prop} for filters), and takes a filter function as a first argument. All other arguments are passed as the arguments to the filter function. As no variables have to be stored for filters, the notation is not traditional in such a way that it doesn't use map. Instead, a JavaScript array lists all filters to be satisfied. Consider the following example: JavaScript allows the declaration of multiple variables in one declaration statement, e.g.:\\\texttt{var a = 1, b = 2;} \\Some companies see this as a bad practice, as it is harder to maintain and less error-prone. A query can be written to to detect all violations of this company policy, by storing the length of the declarations in a variable and checking if the length of the variable is larger than 1. Only the states for which this filter is satisfied will be contained in the results of the query. Listing \ref{lst:multipleDeclarations} illustrates this example.

\begin{lstlisting}[label={lst:multipleDeclarations},language=JSQL, caption=Filtering for multiple declarations,mathescape=true]
G.skipZeroOrMore()
.state({
      node:{declarations: '?decls'},
      properties:{
        '?length' : prop('length', '?decls')
      },
      filters:[
          cond('>', '?length', 1)
      ]
    }) 
\end{lstlisting}

\subsection{Data flow in JS-QL}

Support for data flow opens up to write a whole new class of queries. As JavaScript is a dynamic language, any variable can be assigned to any other variable. This phenomenon is known as \textit{aliasing}, and is very common in the language. As already discussed in chapter \ref{ch:Overview}, JIPDA stores the addresses and values of variables in the \texttt{store}. Values stored for primitive types are indistinguishable in the store, because of abstract interpretation:\\
\texttt{var x = 4; var y = 9999;}\\
Both x and y are integers and will point in the store to a value of \texttt{\{Num\}}. We thus can't track aliasing for primitives. Reference types in JavaScript however are distinguishable in the store as they each point to a set of unique addresses for that reference. Remember that reference types can point to multiple addresses as a consequence of precision loss of abstract interpretation. A feature of the abstract state graph that affects the expressiveness of our language is that it displays states as they are evaluated. This means that for assignments for example, the address of the left-hand side of the assignment often isn't available in the assignment state, as the value (and address) of the right-hand side needs to be evaluated first. This happens \textit{after} the assignment state in the state graph. An example is the simple program: 
\texttt{var x,y; x = \{\}; y = x;}
In this program, \texttt{x} gets assigned a fresh object, after which it gets aliased to \texttt{y}. \texttt{x} and \texttt{y} point to the same set of addresses after execution of this part of the program.
The relevant graph part is depicted in figure \ref{fig:AssignmentLookup}

\begin{figure}[!h]
    \centering
      \includegraphics[width=.5\textwidth]{images/assignmentLookup} 
      \caption{Assignment representation in the state graph}
    \label{fig:AssignmentLookup}
\end{figure}

The problem with this kind of representation in the graph is that when we try to match the assignment in a query, no address information for \texttt{x} is available. After evaluating the fresh object, \texttt{x} gets stored in the store. Later on in the program, \texttt{y} gets assigned the value of \texttt{x}. Now, there is no problem because the address of \texttt{x} is already available in the store, so it can be looked up in the query. Note that the data flow detection in JS-QL isn't nearly as powerful as for example a taint analysis. Queryies and policies can be written to mimic a taint-analysis, but this requires some work. Later in this chapter we will discuss how custom queries and policies can be defined.

Variables can be looked up in JS-QL using the \texttt{lookup} keyword. The value-part of this keyword is again a map with the names of the variables to lookup as keys, and the variable names that need to be bound to the addresses as values. Performing a lookup in JS-QL happens by first looking into the lexical scope. When variables with the same name are defined in both a function and the global scope, the lookup value of that variable will depend on the state that is currently matched. Therefore, we need to provide some sort of mechanism to 'overwrite' this default behavior, in case the address of the global variable is needed when the currently matched state is inside a function application. To this extent, JS-QL recognizes the \texttt{\_global} string as an indicator to perform a lookup in the global scope. Listing \ref{lst:lookup} shows how variables can be looked up. First, the name of the right-hand side node of the assignment expression gets bound to \texttt{?rn}. When the assigment expression gets matched with a state in the global scope, all three address variables \texttt{?rnAddr}, \texttt{?globrnAddr} and \texttt{?xAddr} will have the same value. However, when the assignment on line 7 gets matched, \texttt{?globrnAddr} will point to the globally defined \texttt{x}, whereas the other two lookups contain the address of the locally defined \texttt{x}.

\begin{lstlisting}[label={lst:lookup},language=JSQL, caption=Looking up addresses in JS-QL,mathescape=true]
//Javascript program
var x, y;
x = {};
y = x;
var f = function(){
  var x = 4; //local x gets declared
  y = x;
}
f();
//JS-QL query
G.skipZeroOrMore()
.state({node:{
          expression:{
            type:'AssignmentExpression', right: {name:'?rn'}
        }},
        lookup:{
          '?rn'        : '?rnAddr',     //lookup by variablename
          '_global.?rn': '?globrnAddr', //lookup in global scope
          'x'          : '?xAddr'       //lookup based on name
        }})
\end{lstlisting}



\subsection{Negation}

Expressing which statements and expressions we want to detect on a path in the graph is made easy by JS-QL. Sometimes however, this doesn't suffice for some queries. In some languages, accessing a file after it was closed results in an error in the application. This might compromise the integrity of the system. A naive approach to writing a policy for this would be to detect all calls to the \texttt{access} method that follow, after some wildcard states, the call of a \texttt{close} method for a file \texttt{f}. While this query would match and return all violations against the policy, false positives would occur. This is because of the wildcard states between the two function calls. One of these calls could be a call to the \texttt{open} method, meaning that accessing the file afterwards is permitted.  A better approach would be to specify that we \textit{don't} want to encounter a call to \texttt{open} for \texttt{f} between closing and accessing it. This is exactly what the \texttt{not} construct does. When placing this construct right before a state, the query will only be matched if the negated state can't be matched with the current state in the state graph. When placing \texttt{not} before a state, and \texttt{star} or \texttt{plus} right after that state, it can be read as: "Match zero/one or more states that are \textit{not} the negated state". A better query for the example above would then be written as in listing \ref{lst:OpenClosedFile}, which can be found in the appendix for brevity reasons. The query first skips several states until it reaches a call to \texttt{close} on file \texttt{f}. The address of the file to be closed is also stored in a variable to correctly detect only the accessing and opening of that specific file. Next, all states are matched that are not opening \texttt{f}. Finally, the actual violation is detected, namely accessing the file after it has been closed and not re-opened. Negation is in the current version of JS-QL subject to some limitations: 
\begin{enumerate}
\item Variables that are bound in a negated state, are only visible to that state. They will thus not be included in the resulting substitutions.
\item Currently, only one state can be negated. Negating sequences of states wrapped in braces is not yet supported.
\end{enumerate}

%\subsubsection{Summary of constructs}

%SUMMARY OF BUILT-IN CONSTRUCTS

\section{Types of queries}
\label{sec:TypesOfQueries}

The most straightforward way to query for properties is by just specifying a pattern and an input program. The pattern is then checked and each violating path is reported in the results. Sometimes however other types of queries are needed for the detection of specific policy violations. In this section we discuss the different types of queries and how they can be used.

\subsection{Existential queries}
All queries already presented in this chapter are existential queries. They report a violation of a policy for each path on which they encounter the violation. Existential queries can be defined as follows:
\begin{definition}
\textbf{Existential queries}: Given an edge-labeled directed graph $G$ where labels may have parameters, a vertex $v0$ in $G$, and a parametric regular-expression pattern $P$, compute all pairs of vertex $v$ in $G$ and a substitution $\theta$ for parameters in $P$ such that there exists a path from $v0$ to $v$ in $G$ that matches some sentence accepted by $P$ under $\theta$.
\end{definition}

\noindent What this means is that \textit{any} path in the state graph matching user-defined query will produce a resulting substitution. For that path, the policy has been violated, but chances are that that path never gets executed when actually running the program, as a consequence of the overapproximations of the static analysis in JIPDA. A branch of a conditional might never be executed in a program for example. If the value of the test in the conditional gets overapproximated (i.e. with an abstract value of \textit{\{Bool\}}), the state graph will depict both branches, as it can't decide which branch will be taken. Existential queries thus match a pattern \textit{if there exists a path} in the state graph matching the query.

\subsection{Universal queries}

Sometimes detecting if a pattern occurs along a path in the state graph doesn't suffice. Universal queries provide stronger guarantees for queries, as they require that the query matches for the same substitutions along all possible paths in the state graph between two states. We define universal queries as follows:
\begin{definition}
\textbf{Universal queries}: Given an edge-labeled directed graph $G$ where labels may have parameters, a vertex $v0$ in $G$, and a parametric regular-expression pattern $P$, compute all pairs of vertex $v$ in $G$ and substitution $\theta$ for parameters in $P$ such that every path from $v0$ to $v$ in $G$ matches some sentence accepted by $P$ under $\theta$.
\end{definition}

The intrinsic difference between universal and existential queries is how they match a pattern. Where it suffices for existential queries that just one path exists in the state graph, universal queries make sure that \textit{all} paths between two points in the graph match the specified query. For the sake of a representative example, imagine a JS-QL predicate \texttt{def(\{name:'?x'\})}, which checks all definitions and redefinitions of a variable bound to \texttt{?x}. This variable has a constant value in the state graph as long as no redefinitions of \texttt{?x} happens along any path between two states in the graph. We can then query for each state in the graph where \texttt{?x} has a constant value. The query in listing \ref{lst:UniversalQuery} shows how this can be expressed in JS-QL. Creating such predicates will be discussed in the next section. The definition of a variable \texttt{v} is matched, and any state following that matched state that isn't a redefinition of \texttt{v} will be contained in the result. All states in the state graph up until a redefinition of \texttt{v} (or the end of the graph) will then be marked in color in the user interface.

\begin{lstlisting}[label={lst:UniversalQuery},language=JSQL, caption=Checking for constant folding using a universal query,mathescape=true]
G.skipZeroOrMore()
.def({name: '?x'})            // Define the variable
.not().def({name: '?x'}).star // As long as it isn't redefined
\end{lstlisting}

\subsection{Query direction}

Queries in most traditional systems are viewed as straightforward, in the sense that they match a part of a graph or other program representation from point $a$ to $b$. This way of reasoning implies that queries are always matched from the beginning to the end of a program (if control-flow information is available, that is). Our framework supports this manner of querying in the traditional way, but also allows to explore the state graph bottom-up. This can be meaningful to search for certain program properties. \textit{Forward} queries are queries as we've defined them until now. They match the state graph from the beginning state to the resultstates and are pretty easy to understand and read. \textit{Backward} queries on the other hand traverse the graph in a bottom-up manner, meaning that the query starts at the end of the state graph and matches states until the starting state of the graph is reached. Although backward queries are less common they can be useful to perform some program analysis, such as live variables analysis. This analysis calculates for each program point the variables that may be potentially read before their next write. A variable is thus live if it holds a value that may be needed in the future. The backward query for this analysis goes as follows:

\begin{lstlisting}[label={lst:Liveness},language=JSQL, caption=Live variables anlysis in JS-QL,mathescape=true]
G.skipZeroOrMore()
.use({name: '?x'})            // Read the variable 
.not().def({name: '?x'}).star // As long as it isn't written
\end{lstlisting}

The \texttt{use} and \texttt{def} predicates are again user-defined predicates. Starting from the resultstate of the program, some states are skipped until the first use of variable \texttt{?x} is found. Note that this is in fact the \textit{last} use of that variable in the state graph for that liveness set. The query then marks all states that aren't a write to \texttt{?x}. In this way, one or more states will be marked, representing the path on which variable \texttt{?x} was live.

\section{Defining predicates and policies}
\label{sec:DefiningPolicies}

\subsection{Creating a predicate}
Expressing queries and policies with only the \texttt{state} and \texttt{wildcard} constructs quickly becomes tiresome as every attribute of the state has to be explicitly specified. The JS-QL framework remedies this by letting users specify their own predicates and policies as well as by providing some basic customizable predicates for single expressions and statements.
We can distinguish predicates and policies by what they match. Predicates are like the \texttt{state} construct, in the sense that they match only one specific state. For example, JS-QL has a built-in predicate \texttt{functionCall} which matches function calls. The nice thing about these predicates is that a user can specify what he wants to match in a state. Policies on the other hand are sequences of predicates and/or \texttt{state}s, forming a pattern. We will demonstrate how to write predicates by dissecting a relatively simple built-in predicate called \texttt{assign}. All predicates and policies can be written in a separate file, as long as they are extend in the \textit{JSQL prototype}:\\
\texttt{JSQL.prototype.assign = function(obj)\{\ldots \}}\\
This is the basic notation for named predicates, in this case the \texttt{assign} predicate. The dots in the code above will be filled in by the actual predicate code. We immidiately notice the \texttt{obj} argument. This argument represents the map of all properties of the state that need to be matched. By abstracting the map to a single \texttt{obj} variable, the user is free in which properties and attributes he wishes to match or omit for a specific query. The usefulness of predicates would drastically be reduced if the user has to again pass a nested map of properties to the predicate. We therefore let the developer of the predicate decide which properties he wishes to match, and how he names these properties in the predicate. For the example of the \texttt{assign} predicate, we chose to provide 3 basic attributes to the user: \texttt{this}, \texttt{left} and \texttt{right}, representing the whole assignment node, its left- and right-hand side resp.
\begin{lstlisting}[label={lst:predicateArguments},language=JavaScript, caption=State properties of the \texttt{assign} predicate,mathescape=true]
var s = {}; // variable representing the state
var objThis  = this.getTmpIfUndefined(obj.this); 
var objLeft  = this.getTmpIfUndefined(obj.left); 
var objRight = this.getTmpIfUndefined(obj.right); 
\end{lstlisting}
\noindent A particularly handy feature of JavaScript is the named keys of a map. When accessing such a key in the map (like \texttt{obj.left} for example), the corresponding value is returned when found. When no such key exists, JavaScript returns \texttt{undefined}. To ease the use of predicates, some attributes in the \texttt{obj} map can be made optional. We do this by using the \texttt{getTmpIfUndefined} method, which returns a \textit{temporary variable} when the value for its argument is \texttt{undefined}, and the regular value (a literal or a variable) when it is contained in the map. Temporary variables are variables that won't be contained in the resulting substitutions. By introducing these variables in the code, no conditionals have to be written that check whether an attribute has been specified in the map of a predicate, as we can then just use the temporary variable as a replacement. We instantiate a variable for each attribute as seen in the example. Remember that the attributes can have any name as long as it is clear to the user what the attribute stands for: \texttt{obj.right} could have also been \texttt{obj.abc}, but that would harm the readability of the predicate and confuse the user.

Mapping the attributes of the \texttt{obj} map to a state happens by setting up the state chain. To make things not too complicated for query and predicate developers, we provide a \texttt{setupStateChain} method which does just that. As can be seen in the example above, a map that mimics a state of the state graph is defined though variable \texttt{s}. This variable will be used to build the mimicked state. For each attribute that we provide through the predicate, an entry has to be made in the state map \texttt{s}. We indicate which piece of information we want to match by passing an array of keys we want to traverse in a state as a second argument to \texttt{setupStateChain}. The last key of this array will have the third argument as its value. The first argument is the map in which we want to store this information. When executing line 1 and 2 of listing \ref{lst:predicateState}, \texttt{s} will now contain 1 direct attribute \texttt{node}, which will in turn have 1 attribute \texttt{expression}, which will finally have 2 attributes, \texttt{left} and \texttt{right}. As we only match assignments, we filter the operator of the expression to be '=' on line 4. Note that this is not limited to querying the \texttt{node} property of a state. All information in the state graph can be queried through a predicate.
\begin{lstlisting}[label={lst:predicateState},language=JavaScript, caption=State chain setup of the \texttt{assign} predicate,mathescape=true]
this.setupStateChain(s,['node','this'], objThis);
this.setupStateChain(s,['node','expression','left'], objLeft);
this.setupStateChain(s,['node','expression','right'], objRight); 
this.setupStateChain(s,['node','expression','operator'], '='');
\end{lstlisting}

We want to be able to specify properties, filters and lookups as in regular states. JS-QL allows this in the same way as in states. Putting everything together happens by finalizing each state map (only \texttt{s} in this case) and specifying the state(s) that match the predicate/policy. Listing \ref{lst:predicateFinalize} shows how finalization is done and how the pattern is specified. Finalizing handles things like lookups, filters and properties through the \texttt{finalize} method. This method extracts all relevant information from the \texttt{obj} map and adds it to the state map it gets as a first argument. Finally, the pattern is specified and each state in the pattern gets initialized its own designated state map. For predicates, there will always be at most one state map. Policies however can have multiple state maps, as they represent a sequence of states, each with their own map. This is the only characteristic in which predicates and policies differ. An example of a policy can be seen in listing \ref{lst:WriteToBuiltinObjectPrototype} in the appendix.

\begin{lstlisting}[label={lst:predicateFinalize},language=JavaScript, caption=Finalizing the \texttt{assign} predicate,mathescape=true]
this.finalize(s, obj); //Finalize a specific state
return this.state(s);  //Fill in the state map
\end{lstlisting}

The full code for the predicate is listed in \ref{lst:assignPredicate} in the appendix. We can now use this predicate in any query, with the arguments that we wish to match in a state, as seen below:

\begin{lstlisting}[label={lst:assignCall},language=JSQL, caption=Using the \texttt{assign} predicate,mathescape=true]
G.skipZeroOrMore().assign({left: '?l'})
G.skipZeroOrMore().assign({right: '?r'})
G.skipZeroOrMore().assign({left: '?l', right:'?r',
                           properties:{
                              '?rName' : '?r.name'
                           },
                           lookup:{
                              '?rName' : '?rAddr'
                           }}) 
//And so on ...
\end{lstlisting}

\subsection{recursion}
%moet dit naar types of queries?
Some types of queries or analyses require that a variable is reintroduced in several consecutive states, or that a trace of information is kept along each state. This behavior can be achieved by defining \textit{recursive queries}. Recursive queries are queries that can invoke themselves again, until a base case is matched. This type of query can for example be used to detect by which variables a variable is tainted (i.e. influenced/marked). JS-QL supports recursive queries by providing the \texttt{rec} function. This function takes two arguments: (i) The mapping for the next recursive step and (ii) the predicate/policy that needs to be called recursively. The \texttt{taintedBy} policy is included in the appendix as listing \ref{lst:taintedBy}. It describes a naive taint analysis which only considers simple assignments. It takes three arguments, which can all be omitted: \texttt{orig} denotes the original value which will be aliased, \texttt{alias} represents the alias of the original value and \texttt{rec} keeps track of all variables that have been used as aliases inbetween \texttt{orig} and \texttt{alias}. The relevant code of the policy is found below:

\begin{lstlisting}[label={lst:recursivePolicy},language=JSQL, caption=Recursive call of the \texttt{taintedBy} policy,mathescape=true]
this.setupStateChain(s1, //State map s1
                    ['node','expression','right','name'], orig); 
this.setupStateChain(s1, //State map s1
                    ['node','expression','left','name'], alias); 
this.setupStateChain(s2, //State map s2
                    ['node','expression','right','name'], orig);
this.setupStateChain(s2, //State map s2
                    ['node','expression','left','name'], flow);

return this .lBrace()
            .state(s1)                  //1. From orig to alias
            .or()
            .state(s2)                  //2. From orig to flow
            .skipZeroOrMore()           //   Skip some states
            .rec(newObj,this.taintedBy) //   From flow to alias
            .rBrace();

//JS-QL query:
G.skipZeroOrMore({orig: '?o', alias:'?alias', rec:'?r'})
\end{lstlisting}

The policy matches all simple assignments by name. Lines 1-8 set up the state maps of 2 separate states. The first state matches a direct assignment from \texttt{orig} to \texttt{alias}. The second state does the same, but the alias in this case is an intermediate assigned variable \texttt{flow}. So when we assign $a$ to $b$ and $b$ to $c$, the resulting state can look like: \{orig: a, flow: b, alias: c\}, indicating that $c$ is an alias of $a$, and that it obtained the value of $a$ through $b$. Lines 10-16 show the pattern that needs to be matched. Or we match an assignment directly (the base case), or we match a state from \texttt{orig} to \texttt{flow}, and later in the graph from \texttt{flow} to \texttt{alias}. The recursive call will keep occuring until no more match is found in the state graph, or when the base case is matched. This policy clearly shows that recursive queries can also be used to discover data flow properties of a program. When writing a policy similar to \texttt{taintedBy} which also keeps track of the address of the values, even more accurate data flow properties can be detected.

\section{conclusion}
In this chapter we described the syntax and usage of the JS-QL language. We discussed the basic constructs used to build queries in section \ref{sec:Syntax}, as well as more advanced predicates that are either built-in or that can be user-specified. JS-QL supports several types of policies, and each of them is described in section \ref{sec:TypesOfQueries}.
Writing predicates and policies might seem tiresome at first glance, but actually is quite repetitive and easy to do. The benefit of predicates and policies is that they are 'write once, use often'. A method for defining custom predicates and policies is described in section \ref{sec:DefiningPolicies}. We can conclude that the JS-QL can be learned with little effort, after which expressive queries can be written to check all kinds of code characteristics. 