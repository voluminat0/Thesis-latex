\setcounter{page}{1}
\pagenumbering{arabic} % Start roman numbering 


%korte intro waarover thesis gaat



This dissertation investigates how static analysis can help the user to statically verify user-defined and application-specific security policies. Static analysis benefits from the fact that a program does not have to be compiled to check for program properties, defects and security vulnerabilities. Our thesis is that \textit{a query language based on regular path expressions can be combined with the output of statically analyzing programs to effectively express patterns for detecting security vulnerabilities}, as the result of static analysises contains valuable information that other approaches lack by default. 

Program flaws and vulnerabilities tend to surface late in the development of programs, and they are hard to detect. Earlier approaches in static analysis often consist of a robust framework containing pre-encoded rules and queries to detect the most common programming pitfalls. Although detecting a decent amount of vulnerabilities and supporting a wide range of programs on-the-fly, these approaches overlook certain program flaws that are related to the domain of specific programs. It therefore is important to be able to write succinct queries to test a program against \textit{application-specific} flaws, as most programs differ in behaviour which makes it difficult to write a simple query or pre-encoded rule for a set of different programs. 

We present JS-QL, an embedded domain-specific query language based on regular path queries, built on top of JavaScript. This language allows users to express queries in the native JavaScript language in such a way that queries remain readable and that expressiveness is maximized. JS-QL is used in combination with static analysis to check \textit{user-defined} queries against an abstract state graph, which is a the representation of a program's runtime behaviour resulting from the analysis.


\section{Objectives and contributions}
The use of Javascript for native and web applications is increasing. This has as consequence that malicious users get more creative and passionate about finding security vulnerabilities in these applications and that more program vulnerabilities are discovered and exploited. Developers of applications should be armed with appropriate tools to find these vulnerabilities before their application gets deployed. We present such a tool together with domain-specific query language to aid the user in expressing security policies. Our contributions are the following:
\begin{enumerate}
\item We investigate which type of querying mechanism suits best for expressing security policies and program characteristics in general. We believe that regular path expressions are a suitable for this as they are readable and easy to reason about. The best way to implement such a mechanism is also investigated by comparing different approaches in terms of expressiveness, readability and flexibility.
\item We present the JS-QL \textit{domain-specific language}, a language built to express succinct and highly readable program queries. The application-specific nature of the queries written in the language together with the possibility for users to define these queries by themselves makes it a powerful aid in checking program characteristics and, more precisely, security vulnerabilities. In contrast to general program checkers, a much wider range of program characteristics can be detected.
\item Specifying security policies is one thing, checking them against a program is another. To this extent, we have developed a \textit{tool} to match the queries specified in JS-QL against JavaScript programs. The tool supports multiple types of queries, allowing the user (and thus also developer) to explore their program in several ways. For now, a simple user interface handles all communication with the user, meaning that both input information (the query and the input program) and the output results (all found matches) are displayed in a single window. Although queries are evaluated through the user interface, compound queries can be written and saved in a separate file and are instantly available to the user.
\end{enumerate} 
\section{Overview}

Chapter \ref{ch:Background} discusses the detection of security vulnerabilities. We first give an introduction to static analysis (Section \ref{sec:staticAnalysis}). We discuss the basics of static analysis as wel as a static analysis technique called abstract interpretation. Next, we review existing work for detecting generic vulnerabilities in programs (Section \ref{sec:genericVulnerabilities}). As the goal of this dissertation is to explore a way to express application-specific queries for detecting program vulnerabilities, we also describe some application-specific approaches to query for program characteristics and security vulnerabilities (Section \ref{sec:applicationSpecificVulnerabilities}). In this chapter we show that the approach that seems most apt for this thesis is to combine regular path queries with an abstract state graph.

In chapter \ref{ch:Overview} an overview of our approach is given. We sketch the architecture of our framework and briefly discuss what the roles of each component are (Section \ref{sec:Architecture}). As we traverse an abstract state graph to obtain program information, the reader has to have knowledge of what information that is contained in this graph. We go into greater detail about the information contained in each type of graph node in section \ref{sec:FlowGraphs}. The language developed in this dissertation is a so-called internal domain-specific language (DSL) built on top of JavaScript. Section  \ref{sec:DSLForQueryingGraphs} discusses the benefits of domain-specific languages over general-purpose languages and compares internal domain-specific languages with external ones. Finally, this chapter also explains some of the design constraints for building a domain-specific language as well as design patterns used to implement the JS-QL language (Section \ref{sec:DesignInternalDSL}).

The syntax, semantics and usage of the JS-QL language is explained in chapter \ref{ch:JSQL}. We describe all syntactic aspects of the language in section \ref{sec:Syntax}. Our implementation supports multiple types of queries, such as \textit{existential} and \textit{universal} queries, imposing different rules for a query to produce results. We also explain the difference between \textit{forward} and \textit{backward} queries, in section \ref{sec:TypesOfQueries}. The most important contribution of our approach is that queries are user-defined and application-specific. In section \ref{sec:DefiningPolicies} we describe how queries in JS-QL should be written by leading the user through the different steps by means of an example.

Chapter \ref{ch:Implementation} describes how the framework is implemented and how components work together. We explain how the user interface is implemented and how it sends data to the DSL-layer. We further discuss how this data is processed as well as how the DSL is built. As the matching of the abstract state graph and the query pattern is the core of our framework, we invest in explaining how the matching engine works.

We report on the results of evaluating our approach in chapter \ref{ch:Evaluation} by expressing security policies originating in related work. We checked if and how we can express these queries in JS-QL and evaluated the query verboseness, flexibility, expressiveness and readability. In this chapter we show that JS-QL is well-suited to express different kinds of security policies, but some policies concerning dependencies in a program remain hard to express. 

We conclude in chapter \ref{ch:Conclusion}, and give an overview of our approach's limitations and provide some topics for future research.