\setcounter{page}{1}
\pagenumbering{arabic} % Start roman numbering 


%korte intro waarover thesis gaat

%This dissertation investigates the use of abstract interpretation to detect concurrency
%issues in higher-order programs. Our thesis is that abstract interpretation can be used to
%develop useful analyses in order to find defects in concurrent programs. Moreover, defining
%the analyses with locks as a synchronization primitive instead of the traditional cas leads
%to simpler and more efficient analyses for race conditions and deadlocks.
%Detecting bugs such as race conditions and deadlocks is particularly hard, and they
%tend to appear late in the development of programs. Being able to detect them automatically
%using static analysis tools is therefore important. In this dissertation, we start from
%Might and Van Hornâ€™s PCESK machine, from which we can build a graph of states reachable
%by a higher-order program. We design analyses that use this graph to detect race
%conditions and deadlocks. We then improve the PCESK machine to be able to analyze
%larger programs based on locks. The race condition and deadlock analyses are simplified
%by this improvement, and we are able to analyze more complex programs.

This dissertation investigates how static analysis can help the user to statically verify user-defined and application-specific security policies. Static analysis benefits from the fact that a program doesn't have to be compiled to check for program properties, defects and security vulnerabilities. Our thesis is that a query language based on regular path expressions can be combined with the output of statically analyzing programs to effectively express patterns for detecting security vulnerabilities, as the result of static analysises contains valuable information that other approaches lack by default. Detecting program flaws and vulnerabilities is particularly hard, and they tend to surface late in the development of programs. Earlier approaches in static analysis often consist of a robust framework containing pre-encoded rules and queries to detect the most common programming pitfalls. Although detecting a decent amount of vulnerabilities and supporting a wide range of programs on-the-fly, these approaches overlook certain program flaws that are related to the domain of specific programs. It therefore is important to be able to write succinct queries to test a program against \textit{application-specific} flaws, as most programs differ in behaviour which makes it difficult to write only one query or pre-encoded rule for a set of different programs. We present JS-QL, a domain-specific query language based on regular path queries built on top of JavaScript. This language allows users to express queries in the native JavaScript language in such a way that queries remain readable and that expressiveness is maximized. JS-QL is used in combination with static analysis to check \textit{user-defined} queries against an abstract state graph, which is a program's representation resulting from the analysis.


\section{Objectives and contributions}
As the use of Javascript for native and web applications is booming, more and more JavaScript programs become publicly available. Along with more programs, more security vulnerabilities arise. Malicious individuals keep finding new and innovative ways to exploit program flaws, so developers of applications should be armed with appropriate tools to find these vulnerabilities before their application gets deployed. We present such a tool together with domain-specific query language to aid the user in expressing security policies. Our contributions are the following:
\begin{enumerate}
\item We investigate which type of querying mechanism suits best for expressing security policies and program characteristics in general. We believe that regular path expressions are a good fit for this as they are very readable and easy to reason about. The best way to implement such a mechanism is also investigated by comparing different approaches in terms of expressiveness, readability and flexibility.
\item We present the JS-QL \textit{domain-specific language}, a language built to express succinct and highly readable program queries. The application-specific nature of the queries written in the language together with the possibility for users to define these queries by themselves makes it a powerful aid in checking program characteristics and, more precisely, security vulnerabilities. In contrast to general program checkers, a much wider range of program characteristics can be detected.
\item Specifying security policies is one thing, checking them against a program is another. To this extent, we have developed a \textit{tool} to match the queries specified in JS-QL against JavaScript programs. The tool supports multiple types of queries, allowing the user (and thus also developer) to explore his program in several ways. For now, a simple user interface handles all communication with the user, meaning that both input information (the query and the input program) and the output results (all found matches) are displayed in a single window. Although queries are evaluated through the user interface, compound queries can be written and saved in a separate file and are instantly available to the user.
\end{enumerate} 
\section{Overview}

This dissertation starts with chapter \ref{ch:Background} which discusses the detection of security vulnerabilities. We first give an introduction to static analysis (Section \ref{sec:staticAnalysis}). We discuss the basics of static analysis as wel as a static analysis technique called abstract interpretation. Next, we review existing work for detecting generic vulnerabilities in programs (Section \ref{sec:genericVulnerabilities}). As the goal of this dissertation is to explore a way to express application-specific queries for detecting program vulnerabilities, we also describe some application-specific approaches to query for program characteristics and security vulnerabilities (Section \ref{sec:applicationSpecificVulnerabilities}). We conclude that the approach that seems most apt for this thesis is to combine regular path queries with an abstract state graph.

In chapter \ref{ch:Overview} an overview of our approach is given. We sketch the architecture of our framework and briefly discuss what the roles of each component are (Section \ref{sec:Architecture}). As we traverse an abstract state graph to obtain program information, the reader has to have knowledge of what information that is contained in this graph. We go into greater detail about the information contained in each type of graph node in section \ref{sec:FlowGraphs}. The language developed in this dissertation is a so-called internal domain-specific language (DSL) built on top of JavaScript. Section  \ref{sec:DSLForQueryingGraphs} discusses the benefits of domain-specific languages over general-purpose languages and compares internal domain-specific languages with external ones. Finally, this chapter also explains some of the design constraints for building a domain-specific language as well as design patterns used to implement the JS-QL language (Section \ref{sec:DesignInternalDSL}).

The syntax, semantics and usage of the JS-QL language is explained in chapter \ref{ch:JSQL}. We describe all syntactic aspects of the language in section \ref{sec:Syntax}. Our implementation supports multiple types of queries, such as \textit{existential} and \textit{universal} queries, imposing different rules for a query to produce results. We also explain the difference between \textit{forward} and \textit{backward} queries, all in section \ref{sec:TypesOfQueries}. The most important contribution of our approach is that queries are user-defined and application-specific. In section \ref{sec:DefiningPolicies} we describe how queries in JS-QL should be written by leading the user through the different steps by means of an example.

Chapter \ref{ch:Implementation} describes how the framework is implemented and how components work together. We explain how the user interface is implemented and how it sends data to the DSL-layer. We further discuss how this data is processed as well as how the DSL is built. As the matching of the abstract state graph and the query pattern is the core of our framework, we invest in explaining how the matching engine works.

We evaluated our approach in chapter \ref{ch:Evaluation} by expressing security policies originating from other work. We checked whether we could express these queries in JS-QL and evaluated the query verboseness, flexibility, expressiveness and readability. We concluded that JS-QL is well-suited to express different kinds of security policies, but some policies concerning dependencies in a program remain hard to express. 

We conclude briefly in chapter \ref{ch:Conclusion} and give an overview of our approach's limitations. We finally also provide some topics for future research and explain why this research could be useful.