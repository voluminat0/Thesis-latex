This chapter describes the implementation details of the JS-QL framework and language, as presented in chapter \ref{ch:JSQL}. The implementation of JS-QL is publicly available\footnote{https://github.com/voluminat0/Jipda-Security} and can freely be used to test source code for characteristics and vulnerabilities.


\section{Architecture}
The architecture of the implementation separates each component in a different module, providing the possibility to replace these modules by alternative implementations. In this section we discuss what each component represents.

\subsection*{Datastructures}
The \texttt{DataStructures} module defines all datastructures used in JS-QL. These include all kinds of tuples used for our matching algorithm, but also the alternative representations of edges and nodes to transform the abstract state graph to a compatible graph for the matching engine.

\subsection*{AbstractQuery}
The \texttt{AbstractQuery} module defines the core of the matching engine. It contains all operations on substitution sets: Matching, merging, defining extra properties, filters and lookups. The module provides an interface to the actual query algorithms \texttt{ExistentialQuery} and \texttt{UniversalQuery}, which perform the actual query matching processes.

\subsection*{Automaton}
The \texttt{Automaton} module defines the uniform representation of finite state machines (also known as finite automatons). It abstracts away whether the automaton is a deterministic or non-deterministic automaton, and provides information about the accepting states and starting state of these automatons.

\subsubsection*{ThompsonConstruction}
The \texttt{ThompsonConstruction} module defines an algorithm to convert a regular expression to a NFA (non-deterministic finite automaton). It parses the regular path expression and adds zero or more states to the newly created automaton for each step in the parsing process.
\subsubsection*{SubsetConstruction}
The \texttt{ThompsonConstruction} module defines an algorithm to convert a NFA to a DFA (deterministic finite automaton). What this means is that it eliminates all $\epsilon$-transitions, which are transitions that can occur without reading an input symbol. The resulting automaton is used for both query algorithms.

\subsection*{JipdaInfo}
The \texttt{JipdaInfo} module transforms state information to a more readable format for users. This transformation is necessary to have enforce consistency in states representing an AST node. The transformed states are the actual states that are queried instead of the original JIPDA states.

\subsection*{JSQL}
The \texttt{JSQL} module defines the internals of the JS-QL query language. It is implemented as an embedded DSL in JavaScript and allows users to define application-specific predicates and policies. The module is made available for the user through a fluent interface, increasing the readability of the language.

\subsection*{SecurityAnalysis}
The \texttt{SecurityAnalysis} module glues every component together in the framework. The initialization and transformation of the abstract state graph, execution of queries and processing query results are all invoked by this module.

\section{The user interface}
The JIPDA analysis comes packed with an interface which enables the user to inspect the abstract state graph. This state graph is generated when the user provides an input program and a lattice to perform the abstract interpretation. For our framework we augmented this user interface in several ways described in this section. Figure \ref{fig:UI} shows the user interface, illustrating what we will discuss in the next sections.

\begin{figure}[h]
    \centering
      \includegraphics[width=1\textwidth]{images/UI} 
      \caption{The JS-QL framework user interface}
    \label{fig:UI}
\end{figure}

\subsection*{Query interpretation}

We decided to allow the user to specify queries in the user interface itself. In this way we avoid to switch between different screens and/or files to run just one query. The user interface contains a third-party JavaScript plugin which enables syntax highlighting. We use this plugin as input textboxes for a query and the input program. Along with entering the needed information, a user can decide the kind of query that needs to be executed. This can be done by selecting the direction together with type of query (existential or universal). When hitting the 'detect' button, internally a new \texttt{Query} object is made with the provided query string. Query objects contain three fields: The query direction, its type and a \texttt{JSQL} object, representing the instantiated query. Although being unsafe, the query string is converted to a JSQL object by \texttt{eval}uating it. For the sake of this dissertation, the safety of the application isn't relevant for its functionality.

\subsection*{The abstract state graph}

JIPDA already provided the functionality to display the abstract state graph in the user interface. In order to show results, this representation of the graph needed to be modified so that it became optimal for the user to reason about query results. We changed the following:
\begin{enumerate}
\item \textit{Edge labels}: The JIPDA state graph already contained edge labels, but the information they contained was irrelevant for our approach. As our approach uses edge labels to match states, we had to shift information from nodes to edges. All evaluation states' outgoing edges are also augmented with a visible edge label representing the type of AST node it contains, to make it easier for the user to see what he has to specify in his queries.
\item \textit{State colours}: The default colours of all JIPDA states have been stripped from the graph. This was done to increase the contrast with marked states (i.e. states indicating a match of the query). When the matching engine produced all results, these results have to be transferred to the corresponding states of the state graph. A 'marker' property was added to each matched state, containing the match information as well as a CSS class to highlight them in the otherwise colourless graph. This CSS class can be customised by the user.
\end{enumerate}

\subsection*{Results inspection}

Each query result is a set of substitutions, mapping variables (denoted by a starting \texttt{?}) to their corresponding values in the state graph. Every matching state is marked with its substitution set(s). These results can then be further explored through the results section under the state graph or in the browser's built-in console, which allows to inspect results in even greater detail.


\section{The query language}
The JS-QL query language is implemented as an embedded DSL with JavaScript as its host language. We motivated the use of a DSL in chapter \ref{ch:Overview} and explored the JS-QL syntax and semantics in chapter \ref{ch:JSQL}. This section describes how the DSL is implemented and how we incorporated several DSL implementation techniques.

A JS-QL query gets parsed like a regular expression. Each state in the pattern represents one character in the regular expression, defined by objects of type \texttt{RegexPart}. These parts of the pattern have 5 fields to ease the translation from regular expression to automaton:
\begin{enumerate}
\item \textit{Name}: The name of a regular expression part. In the current implementation, the name just denotes the type of the state/predicate that the \texttt{RegexPart} represents (e.g. \texttt{state, wildcard, not, lbrace, \ldots})
\item \textit{Symbol}: The actual symbol that will be parsed by the parser to set up the automaton corresponding to the query.
\item \textit{Object}: The argument of the state/predicate in which all variables are bound and properties, filters and lookups are specified.
\item \textit{ExpandFunction}: A higher order function representing a recursive predicate or policy that is called for recursive queries. This argument doesn't need to be specified when no recursion happens in a query.
\item \textit{ExpandContext}: A unique identifier to avoid overlapping recursive variable names. Only used for recursive queries.
\end{enumerate}

\noindent States and predicates are actually just function calls returning \texttt{this} to enable method chaining (which is a commonly used technique to implement a fluent interface). Each function call actually represents one state in the pattern, and thus for each of these calls the corresponding \texttt{RegexPart} gets pushed into a map containing the pattern information. 
An exception to this are recursive queries. Recursive query patterns can have an arbitrary amount of states, so we can't model them directly as a sequence of \texttt{RegexPart}s as we don't know the length of the actually matched pattern. We therefore store a whole recursive query in just one \texttt{RegexPart} object, and mark it with 'subgraph' as its name. Further we specify the \texttt{ExpandFunction} and \texttt{-Context} to be able to process the subgraph in the matching algorithm. The idea for treating recursive queries like was adopted from the PQL language\cite{PQL}. The information in this map is unmodified in the sense that the variables aren't resolved yet. The entire query pattern (i.e. the map) is then processed by applying \textit{Thompson's Construction Algorithm} and the \textit{Subset Construction Algorithm} consecutively to obtain a NFA and DFA respectively. These algorithms won't be discussed in too much detail, as they are well described in many online resources and in the literature\cite{Thompson}. An overview of how queries are processed is depicted in figure \ref{fig:QueryProcessing}.

\begin{figure}[!h]
    \centering
      \includegraphics[width=1\textwidth]{images/QueryProcessing} 
      \caption{Stages of processing a query}
    \label{fig:QueryProcessing}
\end{figure}

\subsection*{Regular, temporary and recursive variables}

JS-QL supports three types of variables: Regular, temporary and recursive variables. Each of these types of variables has its own function in the framework:
\begin{enumerate}
\item \textit{Regular variables}: These variables contain the information that the user wants to match in a query. When a match succeeds, they will always be contained in the resulting substitutions.
\item \textit{Recursive variables}: Variables that are used as intermediary variables. They function as a variable that was bound in the previous step of a recursive query, enabling a recursive step to work with the value of one or more variables of the previous step. The \texttt{taintedBy} example used in chapter \ref{ch:JSQL} uses a recursive variable to store all intermediary assignments.
\item \textit{Temporary variables}: These variables are state-local. They are used when a user doesn't specify a certain argument for a predicate or policy. When only specifying the \texttt{left} argument for the \texttt{assign} predicate shown in chapter \ref{ch:JSQL}, the \texttt{right} and \texttt{this} will be bound to temporary variables. These variables get dropped from the resulting substitutions.
\end{enumerate}

\noindent By allowing the user to choose from three types of variables, writing queries becomes very flexible. In this way the bindings in a substitution set can be limited to only the information needed by the user. When imagining JS-QL without the support of temporary variables for example, the size of the substitution set for more complex queries would grow very large very quickly. This greatly decreases the readability of the results and makes interpretation of these results much harder.

\subsection*{Deferring evaluation of properties and filters}

One way to define properties is to use the \texttt{prop} function. Filters on the other hand can be expressed through the \texttt{cond} function. Both of these functions have one thing in common: The value they return depends on the value of the variables specified by the user. The problem now is that the value of these variables is not yet calculated at compile-time. Consider the following example: \texttt{cond('===', '?var', 3)}. Here, the state declaring \texttt{?var} is not yet matched in the state graph, meaning that \texttt{?var} is not yet bound and that we can't check if it is equal to 3. We remedy this by deferring the evaluation of the specified function. Instead of passing the result of evaluating the function directly with its arguments, we wrap them into a \textit{thunk} and pass that thunk to the matching engine. When the matching engine finally needs the value of the thunk, it unwraps it and resolves all variables to the values to which they are bound. If not all variables are bound, the query fails.
%TODO: uitleggen hoe we dit oplossen

\section{The matching engine}

%input en output uitleggen

%paper uitleggen en referencen