\documentclass[a4paper, 12pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[toc,page]{appendix}
\usepackage{graphicx}
\graphicspath{ {images/} }
\usepackage[english]{babel}
\usepackage{listings}
\usepackage{scrextend}
\usepackage{xcolor}
\usepackage{setspace}
\usepackage{stmaryrd}
\usepackage{amsthm}
\usepackage{tikz}
\usetikzlibrary{positioning}
\usepackage{amsfonts}
\newtheorem{definition}{Definition}
\usepackage{caption}
\usepackage{amssymb}% http://ctan.org/pkg/amssymb
\usepackage{pifont}% http://ctan.org/pkg/pifont
\newcommand{\cmark}{\ding{51}}%
\newcommand{\omark}{\ding{109}}%
%\DeclareCaptionFormat{myformat}{#1#2#3\hrulefill}
%\captionsetup{format=myformat}
%\captionsetup[lstlisting]{position=bottom,format=myformat}
% LANGUAGE SETUP FOR LISTINGS

\usepackage{color}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\definecolor{darkgreen}{rgb}{0.13, 0.54, 0.13}

\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{blue}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{darkgreen}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstdefinelanguage{JSON}{
  keywords={test},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={testo},
  ndkeywordstyle=\color{blue}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{darkgreen}\ttfamily,
  stringstyle=\color{black}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
   language=JSON,
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b,
   frame=tb
}

\lstdefinelanguage{JSQL}{
  keywords={G, state, wildcard, skipZeroOrMore, lBrace, rBrace, star, plus, not},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={this, properties, lookup, value, filters, node, benv, store},
  ndkeywordstyle=\color{purple}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{darkgreen}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
   language=JSQL,
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b,
   frame=tb
}

\lstset{
   language=JavaScript,
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b,
   frame=tb
}

\usepackage{blindtext}
\usepackage{enumitem}
 
\usepackage[backend=biber,style=numeric,citestyle=numeric]{biblatex}
\addbibresource{references.bib}
% The following makes latex use nicer postscript fonts.
\usepackage{times}
 
% get clickable links
% http://stackoverflow.com/questions/3244803/latex-add-clickable-links-to-a-section-subsection-with-a-pdf-document
\usepackage{hyperref}
\hypersetup{
  colorlinks   = true,    % Colours links instead of ugly boxes
  urlcolor     = blue,    % Colour for external hyperlinks
  linkcolor    = black,    % Colour of internal links
  citecolor    = black      % Colour of citations
}
 
 
%\usepackage[backend=biber,style=numeric,citestyle=authoryear]{biblatex}
%\usepackage{biblatex}
\makeatletter
% http://tex.stackexchange.com/questions/61204/autocomplete-in-texniccenter-does-not-work-when-biblatex-is-used
% "Since TeXnicCenter does not check for if clauses, it just assumes \bibliography has been used and binds it into the GUI."
%\@ifpackageloaded{biblatex}{\addbibresource{references.bib}}{\bibliography{references}}
\makeatother
       
\usepackage{vubtitlepage}
 
\usepackage{listings}
\hyphenation{mul-ti-di-rec-tio-na-li-ty}
 
\author{Valentijn Spruyt}
\title{Expressing and checking application-specific, user-specified security policies}
\promotor{Prof. Dr. Coen De Roover}
\advisors{Jens Nicolay\\
         Quentin Stievenart}
\degree{Master of Science in Applied Sciences and Engineering: Computer Science}
\faculty{Faculty of Science and Bio-Engineering Sciences}
\advisortitle{Advisors}
\department{Department of Computer Science\\ and Applied Computer Science}
\reason{Graduation thesis submitted in partial fulfillment of the
requirements for the degree of} 

\date{JUNE 2016}
 
\begin{document}

\maketitlepage
 
\advisortitle{Begeleiders}
\faculty{Faculteit Wetenschappen en Bio-\\Ingenieurswetenschappen}
\department{Departement Computerwetenschappen\\en Toegepaste Informatica}
 
\reason{Proefschrift ingediend met het oog op het behalen van de graad
van} %\\
%Master of Science in de Ingenieurswetenschappen: Computerwetenschappen}
\date{JUNI 2016}
 
\maketitlepage


\pagenumbering{roman} % Start roman numbering
\chapter*{Abstract}
 %Security & policies
%Detecting security violations in source code can be tedious, especially when done manually. These violations can usually be split up into several categories, depending on the type of violation.
%daarom is het makkelijk om security policies te gebruiken
 
 %Important because/Not a lot of static JS checkers
 
 %This dissertation ..
 
\chapter*{Acknowledgements}
 
\tableofcontents



%\setcounter{page}{1}
\chapter{Introduction}
\input{chapters/introduction}
\pagenumbering{arabic} % Start roman numbering 

\chapter{Detecting security vulnerabilities}
\input{chapters/background}
 
\chapter{Overview of the approach}
\label{ch:Overview}
\input{chapters/overview}

\chapter{JS-QL: An internal DSL approach for querying flow graphs}
\label{ch:JSQL}
\input{chapters/JSQL}
 
\chapter{Implementation}
\label{ch:Implementation}
\input{chapters/implementation}
 
\chapter{Evaluation}
\input{chapters/evaluation}
 
\chapter{Conclusion and future work}
\input{chapters/conclusion-and-future-work}

\begin{appendices}
\chapter{Compound Policies and queries}

\begin{lstlisting}[label={lst:OpenClosedFile},language=JavaScript,caption=A query for detecting accesses to closed files,mathescape=true]  % float=t?

G.skipZeroOrMore()
.state({node:{
          expression:{
            callee : {name : 'close'},
            arguments: '?args'
        }},
        properties:{
          '?arg' : prop('memberOf','?args'),
          '?argName': '?arg.name'
        },
        lookup:{
          '?argName': '?argAddr' //Match address of the file
        }
       })
.not()
.state({node:{
          expression:{
            callee : {name : 'open'},
            arguments: '?args2'
        }},
        properties:{
          '?arg2' : prop('memberOf','?args2'),
          '?argName2': '?arg2.name'
        },
        lookup:{
          '?argName2': '?argAddr'
        }
       }).star() //Zero or more states
.state({node:{
          expression:{
            callee : {name : 'access'},
            arguments: '?args3'
        }},
        properties:{
          '?arg3' : prop('memberOf','?args3'),
          '?argName3': '?arg3.name'
        },
        lookup:{
          '?argName3': '?argAddr' //Match address of the file
        }
       })
\end{lstlisting}

\begin{lstlisting}[label={lst:assignPredicate},language=JavaScript,caption=The \texttt{assign} predicate,mathescape=true]  % float=t?

JSQL.prototype.writeToBuiltinObjectPrototype = function(obj){
  var obj = obj || {};
  var states = [];
  var frozenObjects = ['Array', 'Boolean', 'Date', 'Function', 'Document', 'Math', 'Window','String'];
  var ret = this.lBrace();
  var objProps = this.getTmpIfUndefined();
  for(var i = 0; i < frozenObjects.length; i++){
    var s = {};
    this.setupStateChain(s, ['node', 'expression', 'left','properties'], objProps);
    this.setupStateChain(s, ['node', 'expression', 'left','mainObjectName'], frozenObjects[i]);
    this.setupFilter(s, 'contains', objProps, 'prototype');
    this.finalize(s, obj);
    states.push(s);
  }
  for(var j = 0; j < states.length; j++){
    if(j !== states.length - 1){
      ret = ret.state(states[j]).or()
    }
    else{
      ret = ret.state(states[j]).rBrace();
    }
  }
  return ret;
}
\end{lstlisting}

\begin{lstlisting}[label={lst:taintedBy},language=JavaScript,caption=The \texttt{taintedBy} recursive policy,mathescape=true]  % float=t?
JSQL.prototype.taintedBy = function(obj){ //x, y, rec
  obj = obj || {};
  var s1 = {};
  var s2 = {};
  var newObj = {};
  var x = this.getTmpIfUndefined(obj.x);
  var y = this.getTmpIfUndefined(obj.y);
  var flow;
  
  if(obj.rec){
    flow = this.getRecVar(obj.rec);
  }
  else{
    flow = this.getTmpIfUndefined();
  }

  newObj.x = flow;
  newObj.y = y;
  newObj.rec = obj.rec;

  this.setupStateChain(s1, ['node','expression','right','name'], x); //alias
  this.setupStateChain(s1, ['node','expression','left','name'], y); //leaked
  this.setupStateChain(s2, ['node','expression','right','name'], x); //alias
  this.setupStateChain(s2, ['node','expression','left','name'], flow); //leaked

  return this .lBrace()
        .state(s1) //assign from x to y
        .or()
        .state(s2) //assign from x to tmp
        .skipZeroOrMore()
        .rec(newObj,this.taintedBy)
        .rBrace();

}
\end{lstlisting}

\begin{lstlisting}[label={lst:WriteToBuiltinObjectPrototype},language=JavaScript,caption=The \texttt{writeToBuiltinObjectPrototype} policy,mathescape=true]  % float=t?

JSQL.prototype.writeToBuiltinObjectPrototype = function(obj){
  var obj = obj || {};
  var states = [];
  var frozenObjects = ['Array', 'Boolean', 'Date', 'Function', 'Document', 'Math', 'Window','String'];
  var ret = this.lBrace();
  var objProps = this.getTmpIfUndefined();
  for(var i = 0; i < frozenObjects.length; i++){
    var s = {};
    this.setupStateChain(s, ['node', 'expression', 'left','properties'], objProps);
    this.setupStateChain(s, ['node', 'expression', 'left','mainObjectName'], frozenObjects[i]);
    this.setupFilter(s, 'contains', objProps, 'prototype');
    this.finalize(s, obj);
    states.push(s);
  }
  for(var j = 0; j < states.length; j++){
    if(j !== states.length - 1){
      ret = ret.state(states[j]).or()
    }
    else{
      ret = ret.state(states[j]).rBrace();
    }
  }
  return ret;
}
\end{lstlisting}



\end{appendices}

\printbibliography
\end{document}