\documentclass[a4paper, 12pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[toc,page]{appendix}
\usepackage{graphicx}
\graphicspath{ {images/} }
\usepackage[english]{babel}
\usepackage{listings}
\usepackage{scrextend}
\usepackage{xcolor}
\usepackage{csquotes}
\usepackage{setspace}
\usepackage{stmaryrd}
\usepackage{multirow}
\usepackage{amsthm}
\usepackage{tikz}
\usetikzlibrary{positioning}
\usepackage{amsfonts}
\newtheorem{definition}{Definition}
\usepackage{caption}
\usepackage{amssymb}% http://ctan.org/pkg/amssymb
\usepackage{pifont}% http://ctan.org/pkg/pifont
\newcommand{\cmark}{\ding{51}}%
\newcommand{\omark}{\ding{109}}%
%\DeclareCaptionFormat{myformat}{#1#2#3\hrulefill}
%\captionsetup{format=myformat}
%\captionsetup[lstlisting]{position=bottom,format=myformat}
% LANGUAGE SETUP FOR LISTINGS

\theoremstyle{definition}

\newtheorem{exmp}{Example}


\usepackage{color}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\definecolor{darkgreen}{rgb}{0.13, 0.54, 0.13}

\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{blue}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{darkgreen}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstdefinelanguage{JSON}{
  keywords={test},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={testo},
  ndkeywordstyle=\color{blue}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{darkgreen}\ttfamily,
  stringstyle=\color{black}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
   language=JSON,
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b,
   frame=tb
}

\lstdefinelanguage{JSQL}{
  keywords={G, state, wildcard, skipZeroOrMore, lBrace, rBrace, star, plus, not},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={this, properties, lookup, value, filters, node, benv, store},
  ndkeywordstyle=\color{purple}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{darkgreen}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
   language=JSQL,
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b,
   frame=tb
}

\lstset{
   language=JavaScript,
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b,
   frame=tb
}

\usepackage{blindtext}
\usepackage{enumitem}
%\usepackage[style=apa,backend=biber,language=american]{biblatex}
%\DeclareLanguageMapping{american}{american-apa}
\usepackage[backend=biber,style=numeric,citestyle=numeric]{biblatex}
\addbibresource{references.bib}
% The following makes latex use nicer postscript fonts.
\usepackage{times}
 
% get clickable links
% http://stackoverflow.com/questions/3244803/latex-add-clickable-links-to-a-section-subsection-with-a-pdf-document
\usepackage{hyperref}
\hypersetup{
  colorlinks   = true,    % Colours links instead of ugly boxes
  urlcolor     = blue,    % Colour for external hyperlinks
  linkcolor    = black,    % Colour of internal links
  citecolor    = black      % Colour of citations
}
 
 
%\usepackage[backend=biber,style=numeric,citestyle=authoryear]{biblatex}
%\usepackage{biblatex}
\makeatletter
% http://tex.stackexchange.com/questions/61204/autocomplete-in-texniccenter-does-not-work-when-biblatex-is-used
% "Since TeXnicCenter does not check for if clauses, it just assumes \bibliography has been used and binds it into the GUI."
%\@ifpackageloaded{biblatex}{\addbibresource{references.bib}}{\bibliography{references}}
\makeatother
       
\usepackage{vubtitlepage}
 
\usepackage{listings}
\hyphenation{mul-ti-di-rec-tio-na-li-ty}
 
\author{Valentijn Spruyt}
\title{Static detection of user-specified \\ security vulnerabilities in client-side\\ JavaScript}
\promotor{Prof. Dr. Coen De Roover}
\advisors{Jens Nicolay\\
         Quentin Sti\'{e}venart}
\degree{Master of Science in de Ingenieurswetenschappen: Computerwetenschappen}
\faculty{Faculty of Science and Bio-Engineering Sciences}
\advisortitle{Advisors}
\department{Department of Computer Science\\ and Applied Computer Science}
\reason{Graduation thesis submitted in partial fulfillment of the
requirements for the degree of} 

\date{JUNE 2016}
 
\begin{document}

\maketitlepage
 
\advisortitle{Begeleiders}
\faculty{Faculteit Wetenschappen en Bio-\\Ingenieurswetenschappen}
\department{Departement Computerwetenschappen\\en Toegepaste Informatica}
 
\reason{Proefschrift ingediend met het oog op het behalen van de graad
van} %\\
%Master of Science in de Ingenieurswetenschappen: Computerwetenschappen}
\date{JUNI 2016}
 
\maketitlepage


\pagenumbering{roman} % Start roman numbering
\chapter*{Abstract}

%Why
Program flaws and vulnerabilities tend to surface late in the development of programs, and they are hard to detect. Existing approaches often consist of a robust framework containing pre-encoded rules and queries to detect the most common programming pitfalls. Although these approaches are able to detect a decent amount of vulnerabilities and support a wide range of programs on-the-fly, they overlook certain program flaws that are related to the application domain of specific programs.

%What in thesis onderzocht
In this dissertation, we investigate how static analysis can aid in detecting application-specific security vulnerabilities. As these vulnerabilities are not general enough to be checked by tools that use a database of pre-encoded patterns, developers should be able to write rules that are specifically applicable to their program. 

%Hoe
We present the JS-QL framework, a tool for statically checking user-specified security vulnerabilities in JavaScript applications. The framework makes use of JS-QL, an embedded domain-specific query language built on top of JavaScript. JS-QL queries are based on regular path expressions, enabling users to express queries in an intuitive way. 

%Resultaten
We evaluated our framework by comparing our language with other query languages in terms of expressiveness. We conclude that the combination of static analysis and regular path expressions is well-suited to specify security policies and detect program vulnerabilities.
 
\chapter*{Acknowledgements}
 
%ouders for opportunity
I am most thankful towards my promotor Coen De Roover and my supervisors Jens Nicolay and Quentin Sti\'{e}venart for their valuable advice and helpful comments throughout the year. They helped me focus on the important parts of my thesis and kept me motivated. I would also like to thank my friends Jonas and Dylan for their support and encouragement to keep working on this dissertation, even in periods when I lacked motivation. I admire my loving girlfriend for standing by my side through this period and for putting up with my stressful behaviour. I am also grateful for the opportunity my parents gave me to go to university to get my masters degree. Finally, I would also like to thank my friend Ben for reading most parts of this work. I appreciate his comments and insights greatly.

\tableofcontents



\chapter{Introduction}
\input{chapters/introduction}


\chapter{Detecting security vulnerabilities}
\label{ch:Background}
\input{chapters/background}
 
\chapter{Overview of the approach}
\label{ch:Overview}
\input{chapters/overview}

\chapter{JS-QL: An internal DSL approach for querying flow graphs}
\label{ch:JSQL}
\input{chapters/JSQL}
 
\chapter{Implementation}
\label{ch:Implementation}
\input{chapters/implementation}
 
\chapter{Evaluation}
\label{ch:Evaluation}
\input{chapters/evaluation}
 
\chapter{Conclusion and future work}
\label{ch:Conclusion}
\input{chapters/conclusion-and-future-work}

\begin{appendices}
\chapter{JS-QL policies and predicates}

\begin{lstlisting}[label={lst:OpenClosedFile},language=JavaScript,caption=A query for detecting accesses to closed files,mathescape=true]  % float=t?

G.skipZeroOrMore()
.state({node:{
          expression:{
            callee : {name : 'close'},
            arguments: '?args'
        }},
        properties:{
          '?arg' : prop('memberOf','?args'),
          '?argName': '?arg.name'
        },
        lookup:{
          '?argName': '?argAddr' //Match address of the file
        }
       })
.not()
.state({node:{
          expression:{
            callee : {name : 'open'},
            arguments: '?args2'
        }},
        properties:{
          '?arg2' : prop('memberOf','?args2'),
          '?argName2': '?arg2.name'
        },
        lookup:{
          '?argName2': '?argAddr'
        }
       }).star() //Zero or more states
.state({node:{
          expression:{
            callee : {name : 'access'},
            arguments: '?args3'
        }},
        properties:{
          '?arg3' : prop('memberOf','?args3'),
          '?argName3': '?arg3.name'
        },
        lookup:{
          '?argName3': '?argAddr' //Match address of the file
        }
       })
\end{lstlisting}

\begin{lstlisting}[label={lst:assignPredicate},language=JavaScript,caption=The \texttt{assign} predicate,mathescape=true]  % float=t?

JSQL.prototype.writeToBuiltinObjectPrototype = function(obj){
  var obj = obj || {};
  var states = [];
  var frozenObjects = ['Array', 'Boolean', 'Date', 'Function', 'Document', 'Math', 'Window','String'];
  var ret = this.lBrace();
  var objProps = this.getTmpIfUndefined();
  for(var i = 0; i < frozenObjects.length; i++){
    var s = {};
    this.setupStateChain(s, ['node', 'expression', 'left','properties'], objProps);
    this.setupStateChain(s, ['node', 'expression', 'left','mainObjectName'], frozenObjects[i]);
    this.setupFilter(s, 'contains', objProps, 'prototype');
    this.finalize(s, obj);
    states.push(s);
  }
  for(var j = 0; j < states.length; j++){
    if(j !== states.length - 1){
      ret = ret.state(states[j]).or()
    }
    else{
      ret = ret.state(states[j]).rBrace();
    }
  }
  return ret;
}
\end{lstlisting}

\begin{lstlisting}[label={lst:taintedBy},language=JavaScript,caption=The \texttt{taintedBy} recursive policy,mathescape=true]  % float=t?
JSQL.prototype.taintedBy = function(obj){ //x, y, rec
  obj = obj || {};
  var s1 = {};
  var s2 = {};
  var newObj = {};
  var x = this.getTmpIfUndefined(obj.x);
  var y = this.getTmpIfUndefined(obj.y);
  var flow;
  
  if(obj.rec){
    flow = this.getRecVar(obj.rec);
  }
  else{
    flow = this.getTmpIfUndefined();
  }

  newObj.x = flow;
  newObj.y = y;
  newObj.rec = obj.rec;

  this.setupStateChain(s1, ['node','expression','right','name'], x); //alias
  this.setupStateChain(s1, ['node','expression','left','name'], y); //leaked
  this.setupStateChain(s2, ['node','expression','right','name'], x); //alias
  this.setupStateChain(s2, ['node','expression','left','name'], flow); //leaked

  return this .lBrace()
        .state(s1) //assign from x to y
        .or()
        .state(s2) //assign from x to tmp
        .skipZeroOrMore()
        .rec(newObj,this.taintedBy)
        .rBrace();

}
\end{lstlisting}

\begin{lstlisting}[label={lst:WriteToBuiltinObjectPrototype},language=JavaScript,caption=The \texttt{writeToBuiltinObjectPrototype} policy,mathescape=true]  % float=t?

JSQL.prototype.writeToBuiltinObjectPrototype = function(obj){
  var obj = obj || {};
  var states = [];
  var frozenObjects = ['Array', 'Boolean', 'Date', 'Function', 'Document', 'Math', 'Window','String'];
  var ret = this.lBrace();
  var objProps = this.getTmpIfUndefined();
  for(var i = 0; i < frozenObjects.length; i++){
    var s = {};
    this.setupStateChain(s, ['node', 'expression', 'left','properties'], objProps);
    this.setupStateChain(s, ['node', 'expression', 'left','mainObjectName'], frozenObjects[i]);
    this.setupFilter(s, 'contains', objProps, 'prototype');
    this.finalize(s, obj);
    states.push(s);
  }
  for(var j = 0; j < states.length; j++){
    if(j !== states.length - 1){
      ret = ret.state(states[j]).or()
    }
    else{
      ret = ret.state(states[j]).rBrace();
    }
  }
  return ret;
}
\end{lstlisting}



\end{appendices}

\printbibliography
\end{document}