\documentclass[a4paper, 12pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[toc,page]{appendix}
\usepackage{graphicx}
\graphicspath{ {images/} }
\usepackage[english]{babel}
\usepackage{listings}
\usepackage{scrextend}
\usepackage{xcolor}
\usepackage{csquotes}
\usepackage{setspace}
\usepackage{stmaryrd}
\usepackage{multirow}
\usepackage{amsthm}
\usepackage{tikz}
\usetikzlibrary{positioning}
\usepackage{amsfonts}
\newtheorem{definition}{Definition}
\usepackage{caption}
\usepackage{amssymb}% http://ctan.org/pkg/amssymb
\usepackage{pifont}% http://ctan.org/pkg/pifont
\newcommand{\cmark}{\ding{51}}%
\newcommand{\omark}{\ding{109}}%
%\DeclareCaptionFormat{myformat}{#1#2#3\hrulefill}
%\captionsetup{format=myformat}
%\captionsetup[lstlisting]{position=bottom,format=myformat}
% LANGUAGE SETUP FOR LISTINGS

\theoremstyle{definition}

\newtheorem{exmp}{Example}


\usepackage{color}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\definecolor{darkgreen}{rgb}{0.13, 0.54, 0.13}

\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{blue}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{darkgreen}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstdefinelanguage{JSON}{
  keywords={test},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={testo},
  ndkeywordstyle=\color{blue}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{darkgreen}\ttfamily,
  stringstyle=\color{black}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
   language=JSON,
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b,
   frame=tb
}

\lstdefinelanguage{JSQL}{
  keywords={G, state, wildcard, skipZeroOrMore, lBrace, rBrace, star, plus, not},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={this, properties, lookup, value, filters, node, benv, store},
  ndkeywordstyle=\color{purple}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{darkgreen}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
   language=JSQL,
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b,
   frame=tb
}

\lstset{
   language=JavaScript,
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b,
   frame=tb
}

\usepackage{blindtext}
\usepackage{enumitem}
%\usepackage[style=apa,backend=biber,language=american]{biblatex}
%\DeclareLanguageMapping{american}{american-apa}
\usepackage[backend=biber,style=numeric,citestyle=numeric]{biblatex}
\addbibresource{references.bib}
% The following makes latex use nicer postscript fonts.
\usepackage{times}
 
% get clickable links
% http://stackoverflow.com/questions/3244803/latex-add-clickable-links-to-a-section-subsection-with-a-pdf-document
\usepackage{hyperref}
\hypersetup{
  colorlinks   = true,    % Colours links instead of ugly boxes
  urlcolor     = blue,    % Colour for external hyperlinks
  linkcolor    = black,    % Colour of internal links
  citecolor    = black      % Colour of citations
}
 
 
%\usepackage[backend=biber,style=numeric,citestyle=authoryear]{biblatex}
%\usepackage{biblatex}
\makeatletter
% http://tex.stackexchange.com/questions/61204/autocomplete-in-texniccenter-does-not-work-when-biblatex-is-used
% "Since TeXnicCenter does not check for if clauses, it just assumes \bibliography has been used and binds it into the GUI."
%\@ifpackageloaded{biblatex}{\addbibresource{references.bib}}{\bibliography{references}}
\makeatother
       
\usepackage{vubtitlepage}
 
\usepackage{listings}
\hyphenation{mul-ti-di-rec-tio-na-li-ty}
 
\author{Valentijn Spruyt}
\title{Static detection of user-specified \\ security vulnerabilities in client-side\\ JavaScript}
\promotor{Prof. Dr. Coen De Roover}
\advisors{Jens Nicolay\\
         Quentin Sti\'{e}venart}
\degree{Master of Science in de Ingenieurswetenschappen: Computerwetenschappen}
\faculty{Faculty of Science and Bio-Engineering Sciences}
\advisortitle{Advisors}
\department{Department of Computer Science\\ and Applied Computer Science}
\reason{Graduation thesis submitted in partial fulfillment of the
requirements for the degree of} 

\date{JUNE 2016}
 
\begin{document}

\maketitlepage
 
\advisortitle{Begeleiders}
\faculty{Faculteit Wetenschappen en Bio-\\Ingenieurswetenschappen}
\department{Departement Computerwetenschappen\\en Toegepaste Informatica}
 
\reason{Proefschrift ingediend met het oog op het behalen van de graad
van} %\\
%Master of Science in de Ingenieurswetenschappen: Computerwetenschappen}
\date{JUNI 2016}
 
\maketitlepage


\pagenumbering{roman} % Start roman numbering
\chapter*{Abstract}

%Why
Program defects tend to surface late in the development of programs, and they are hard to detect.
%TODO: security vulnerabilities, such as ..
The same goes for security vulnerabilities. This type of program defects is particularly important to detect as they might leak sensitive information or even compromise the system on which the program is executed.
%TODO: Tools static, + benefit: goed omdat at compile time

A popular approach for analyzing programs is static analysis. Static analysis of a program is performed at compile time, implying that the program can be analyzed without being executed.
 Existing approaches using static analysis to detect security vulnerabilities in source code are often limited to a predetermined set of pre-encoded security vulnerabilities. Although these approaches are able to detect a decent amount of vulnerabilities and support a wide range of programs by default, they lack the means to be configured for vulnerabilities that are specific for the particular application domain of the analyzed program.

%What in thesis onderzocht
In this dissertation, we investigate how static analysis can aid in detecting application-specific security vulnerabilities. As these vulnerabilities are not general enough to be checked by tools that use a database of pre-encoded patterns, developers should be able to write rules that are specifically applicable to their program. 

%Hoe
We present JS-QL, a tool for statically checking user-specified security vulnerabilities in JavaScript applications. The tool makes use of an embedded domain-specific query language built on top of JavaScript. JS-QL queries are based on regular path expressions, enabling users to express queries in an intuitive way. These expressions are a way of declaratively expressing queries on graphs as regular-expression-like patterns. In the context of this dissertation, regular path expressions are used to match user-specified patterns on an abstract state graph, which is generated as the output of performing static analysis. 

%Resultaten
We evaluated our approach by comparing our language with other languages for expressing security vulnerabilities in terms of expressiveness. We conclude that the combination of static analysis and regular path expressions lends itself well to the detection of user-specified security vulnerabilities.

\chapter*{Samenvatting}

Tekortkomingen in programma's zijn moeilijk te detecteren en ze komen vaak pas laat aan de oppervlakte in het ontwikkelingsproces. Hetzelfde geldt voor beveiligingslekken. Dit soort van kwetsbaarheden is uitermate belangrijk om op te sporen, aangezien ze mogelijks geheime informatie lekken of er zelfs voor kunnen zorgen dat het systeem waarop het programma draait gecomprommiteerd wordt.
 
Een populaire aanpak om programma's te analyseren is statische analyse. Statische analyse van een programma wordt uitgevoerd at compile time, wat betekent dat het programma kan geanalyseerd worden zonder het uit te voeren. Bestaande oplossingen die gebruik maken van statische analyse om beveiligingslekken op te sporen in broncode zijn vaak beperkt tot een voorafbepaalde set van voorgeprogrammeerde programmapatronen. Hoewel deze oplossingen een redelijk aantal kwetsbaarheden in programma's vinden, ontbreken ze een manier om geconfigureerd te worden om kwetsbaarheden te vinden binnen het domein van het geanalyseerde programma.

In dit proefschrift onderzoeken we hoe statisch analyse kan helpen om programmaspecifieke beveiligingslekken te detecteren. Aangezien deze beveiligingslekken niet algemeen genoeg zijn om gevonden te worden door tools die een databank van voorgeprogrammeerde patronen gebruiken, zouden ontwikkelaars de mogelijkheid moeten hebben om zelf patronen te schrijven die toepasbaar zijn op hun specifieke programma's.

We stellen JS-QL voor, een tool om op statische manier beveiligingslekken, gespecificeerd door de gebruiker, in JavaScript applicaties te detecteren. De tool gebruikt een embedded domein-specifieke querytaal die gebouwd is bovenop JavaScript. JS-QL queries zijn gebaseerd op regular path expressions die de gebruiker er toe in staat stellen queries uit te drukken op een intuitieve manier. Regular path expressions zijn een manier om declaratief queries op graphs uit te drukken, gelijkaardig aan de notatie van reguliere expressies. Binnen de context van dit proefschrift worden regular path expressions gebruikt om patronen, gespecificeerd door gebruikers, te matchen tegen een abstract state graph die gegenereerd wordt als output van statische analyse.

We hebben onze aanpak geëvalueerd door onze taal op vlak van expressiviteit te vergelijken met andere talen waarin beveiligingslekken uitgedrukt kunnen worden. We besluiten dat de combinatie van statische analyse en regular path expressions zich goed leent tot het opsporen van beveiligingslekken die door de gebruiker gespecificeerd zijn.

\chapter*{Acknowledgements}
 
%ouders for opportunity
I am most thankful towards my promotor Coen De Roover and my supervisors Jens Nicolay and Quentin Sti\'{e}venart for their valuable advice and helpful comments throughout the year. They helped me focus on the important parts of my thesis and kept me motivated. I would also like to thank my friends Jonas and Dylan for their support and encouragement to keep working on this dissertation, even in periods when I lacked motivation. I admire my loving girlfriend for standing by my side through this period and for putting up with my stressful behaviour. I am also grateful for the opportunity my parents gave me to go to university to get my masters degree. Finally, I would also like to thank my friend Ben for reading most parts of this work. I appreciate his comments and insights greatly.

\tableofcontents

\listoffigures
\listoftables


\chapter{Introduction}
\input{chapters/introduction}


\chapter{Detecting security vulnerabilities}
\label{ch:Background}
\input{chapters/background}
 
\chapter{Overview of the approach}
\label{ch:Overview}
\input{chapters/overview}

\chapter{JS-QL: An internal DSL approach for querying flow graphs}
\label{ch:JSQL}
\input{chapters/JSQL}
 
\chapter{Implementation}
\label{ch:Implementation}
\input{chapters/implementation}
 
\chapter{Evaluation}
\label{ch:Evaluation}
\input{chapters/evaluation}
 
\chapter{Conclusion and future work}
\label{ch:Conclusion}
\input{chapters/conclusion-and-future-work}

\begin{appendices}
\chapter{JS-QL policies and predicates}

\begin{lstlisting}[label={lst:OpenClosedFile},language=JavaScript,caption=A query for detecting accesses to closed files,mathescape=true]  % float=t?

G.skipZeroOrMore()
.state({node:{
          expression:{
            callee : {name : 'close'},
            arguments: '?args'
        }},
        properties:{
          '?arg' : prop('memberOf','?args'),
          '?argName': '?arg.name'
        },
        lookup:{
          '?argName': '?argAddr' //Match address of the file
        }
       })
.not()
.state({node:{
          expression:{
            callee : {name : 'open'},
            arguments: '?args2'
        }},
        properties:{
          '?arg2' : prop('memberOf','?args2'),
          '?argName2': '?arg2.name'
        },
        lookup:{
          '?argName2': '?argAddr'
        }
       }).star() //Zero or more states
.state({node:{
          expression:{
            callee : {name : 'access'},
            arguments: '?args3'
        }},
        properties:{
          '?arg3' : prop('memberOf','?args3'),
          '?argName3': '?arg3.name'
        },
        lookup:{
          '?argName3': '?argAddr' //Match address of the file
        }
       })
\end{lstlisting}

\begin{lstlisting}[label={lst:assignPredicate},language=JavaScript,caption=The \texttt{assign} predicate,mathescape=true]  % float=t?

JSQL.prototype.writeToBuiltinObjectPrototype = function(obj){
  var obj = obj || {};
  var states = [];
  var frozenObjects = ['Array', 'Boolean', 'Date', 'Function', 'Document', 'Math', 'Window','String'];
  var ret = this.lBrace();
  var objProps = this.getTmpIfUndefined();
  for(var i = 0; i < frozenObjects.length; i++){
    var s = {};
    this.setupStateChain(s, ['node', 'expression', 'left','properties'], objProps);
    this.setupStateChain(s, ['node', 'expression', 'left','mainObjectName'], frozenObjects[i]);
    this.setupFilter(s, 'contains', objProps, 'prototype');
    this.finalize(s, obj);
    states.push(s);
  }
  for(var j = 0; j < states.length; j++){
    if(j !== states.length - 1){
      ret = ret.state(states[j]).or()
    }
    else{
      ret = ret.state(states[j]).rBrace();
    }
  }
  return ret;
}
\end{lstlisting}

\begin{lstlisting}[label={lst:taintedBy},language=JavaScript,caption=The \texttt{taintedBy} recursive policy,mathescape=true]  % float=t?
JSQL.prototype.taintedBy = function(obj){ //x, y, rec
  obj = obj || {};
  var s1 = {};
  var s2 = {};
  var newObj = {};
  var x = this.getTmpIfUndefined(obj.x);
  var y = this.getTmpIfUndefined(obj.y);
  var flow;
  
  if(obj.rec){
    flow = this.getRecVar(obj.rec);
  }
  else{
    flow = this.getTmpIfUndefined();
  }

  newObj.x = flow;
  newObj.y = y;
  newObj.rec = obj.rec;

  this.setupStateChain(s1, ['node','expression','right','name'], x); //alias
  this.setupStateChain(s1, ['node','expression','left','name'], y); //leaked
  this.setupStateChain(s2, ['node','expression','right','name'], x); //alias
  this.setupStateChain(s2, ['node','expression','left','name'], flow); //leaked

  return this .lBrace()
        .state(s1) //assign from x to y
        .or()
        .state(s2) //assign from x to tmp
        .skipZeroOrMore()
        .rec(newObj,this.taintedBy)
        .rBrace();

}
\end{lstlisting}

\begin{lstlisting}[label={lst:WriteToBuiltinObjectPrototype},language=JavaScript,caption=The \texttt{writeToBuiltinObjectPrototype} policy,mathescape=true]  % float=t?

JSQL.prototype.writeToBuiltinObjectPrototype = function(obj){
  var obj = obj || {};
  var states = [];
  var frozenObjects = ['Array', 'Boolean', 'Date', 'Function', 'Document', 'Math', 'Window','String'];
  var ret = this.lBrace();
  var objProps = this.getTmpIfUndefined();
  for(var i = 0; i < frozenObjects.length; i++){
    var s = {};
    this.setupStateChain(s, ['node', 'expression', 'left','properties'], objProps);
    this.setupStateChain(s, ['node', 'expression', 'left','mainObjectName'], frozenObjects[i]);
    this.setupFilter(s, 'contains', objProps, 'prototype');
    this.finalize(s, obj);
    states.push(s);
  }
  for(var j = 0; j < states.length; j++){
    if(j !== states.length - 1){
      ret = ret.state(states[j]).or()
    }
    else{
      ret = ret.state(states[j]).rBrace();
    }
  }
  return ret;
}
\end{lstlisting}



\end{appendices}

\printbibliography
\end{document}